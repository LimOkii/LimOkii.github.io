<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BERT</title>
    <url>/2023/07/02/Bert/</url>
    <content><![CDATA[<p>本章是BERT模型概述，比较简略，大多数概念在Transformer精讲中提到</p>
<span id="more"></span>

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>BERT 全称为 <strong>Bidirectional Encoder Representation from Transformer</strong>，是 Google 以无监督的方式利用大量<strong>无标注</strong>文本训练出的的语言模型，其架构为 Transformer 中的 Encoder。</p>
<p>下文出现有关Transformer的概念将不再介绍，可参考之前的博客。</p>
<p>在BERT 之前，为了解决不同的 NLP 任务，人们通常会为该任务设计一个最合适的神经网络架构并做训练</p>
<p>不同的 NLP 任务通常需要不同的模型，而设计这些模型并测试其效果是非常耗成本的（人力，时间，计算资源） </p>
<p><strong>如果有一个能直接处理各式 NLP 任务的通用架构该有多好？</strong></p>
<p>随着时代演进，不少人很自然地有了这样子的想法，而 BERT 就是其中一个将此概念付诸实践的例子</p>
<p>Google 在预训练 BERT 时让它同时进行两个任务：</p>
<img src="/2023/07/02/Bert/1709118986826-1709118997567-2.jpg" alt="1709118986826" style="zoom: 50%;">

<p>1、<strong>Masked Language Model</strong>：类似于完形填空</p>
<p>2、<strong>Next Sentence Prediction</strong>：下一个句子的预测</p>
<h2 id="二、Masked-Language-Model"><a href="#二、Masked-Language-Model" class="headerlink" title="二、Masked Language Model"></a>二、Masked Language Model</h2><p>在 BERT 中，Masked LM（Masked Language Model）构建了语言模型，简单来说，就是<strong>随机遮盖或替换</strong>一句话里面的任意字或词，然后让模型通过上下文预测那一个被遮盖或替换的部分，之后<strong>做 Loss 的时候也只计算被遮盖部分的 Loss</strong>，这其实是一个很容易理解的任务，实际操作如下：</p>
<p>1、随机把一句话中 15% 的 token（字或词）替换成以下内容：</p>
<ol>
<li><p>这些 token 有 80% 的几率被替换成 <code>[MASK]</code>，例如 <code>my dog is hairy→my dog is [MASK]</code></p>
</li>
<li><p>有 10% 的几率被替换成任意一个其它的 token，例如 <code>my dog is hairy→my dog is apple</code></p>
</li>
<li><p>有 10% 的几率原封不动，例如 <code>my dog is hairy→my dog is hairy</code></p>
</li>
</ol>
<p>2、之后让模型<strong>预测和还原</strong>被遮盖掉或替换掉的部分，计算损失的时候，只计算在第 1 步里被<strong>随机遮盖或替换</strong>的部分，其余部分不做损失，其余部分无论输出什么东西，都无所谓</p>
<p>这样做的好处是，BERT 并不知道 <code>[MASK]</code> 替换的是哪一个词，而且任何一个词都有可能是被替换掉的，比如它看到的 apple 可能是被替换的词。这样强迫模型在编码当前时刻词的时候不能太依赖当前的词，而要考虑它的上下文，甚至根据上下文进行 “纠错”。比如上面的例子中，模型在编码 apple 时，根据上下文 my dog is，应该把 apple 编码成 hairy 的语义而不是 apple 的语义</p>
<h2 id="三、Next-Sentence-Prediction"><a href="#三、Next-Sentence-Prediction" class="headerlink" title="三、Next Sentence Prediction"></a>三、Next Sentence Prediction</h2><p>我们首先拿到属于上下文的一对句子，也就是两个句子，之后我们要在这两个句子中加一些特殊的 token：<code>[CLS]上一句话[SEP]下一句话[SEP]</code>。也就是在句子开头加一个 <code>[CLS]</code>，在两句话之间和句末加 <code>[SEP]</code>，具体地如下图所示</p>
<img src="/2023/07/02/Bert/image-20240228192818061.png" alt="image-20240228192818061" style="zoom: 67%;">

<p>可以看到，上图中的两句话明显是连续的。如果现在有这么一句话 <code>[CLS]我的狗很可爱[SEP]你今天吃了吗[SEP]</code>，可见这两句话就不是连续的。在实际训练中，我们会让这两种情况出现的数量为 <strong>1:1</strong></p>
<p><strong>Token Embedding</strong>就是正常的词向量，即 <code>PyTorch</code> 中的 <code>nn.Embedding()</code></p>
<p><strong>Segment Embedding</strong>的作用是用 embedding 的信息让模型分开上下句，我们给上句的 token 全 0，下句的 token 全 1，让模型得以判断上下句的起止位置，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[CLS]我的狗很可爱[SEP]你今天吃了吗[SEP]</span><br><span class="line"> 0   0 0 0 0 0 0 0  1 1 1 1 1 1 1 </span><br></pre></td></tr></table></figure>

<p><strong>Position Embedding</strong> 和 Transformer 中的不一样，不是三角函数，而是学习出来的</p>
<h2 id="四、训练-微调"><a href="#四、训练-微调" class="headerlink" title="四、训练&amp;微调"></a>四、训练&amp;微调</h2><h4 id="Multi-Task-Learning"><a href="#Multi-Task-Learning" class="headerlink" title="Multi-Task Learning"></a>Multi-Task Learning</h4><p>BERT 预训练阶段实际上是将上述两个任务结合起来，同时进行，然后将所有的 Loss 相加，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[CLS] calculus is a branch of math [SEP] panda is native to [MASK] central china [SEP]</span><br><span class="line"></span><br><span class="line">Targets: false, south</span><br><span class="line">----------------------------------</span><br><span class="line">Input:</span><br><span class="line">[CLS] calculus is a [MASK] of math [SEP] it [MASK] developed by newton and leibniz [SEP]</span><br><span class="line"></span><br><span class="line">Targets: true, branch, was</span><br></pre></td></tr></table></figure>

<h4 id="Fine-Tuning"><a href="#Fine-Tuning" class="headerlink" title="Fine-Tuning"></a>Fine-Tuning</h4><p>BERT 的 Fine-Tuning 共分为 4 中类型</p>
<p>1、如果现在的任务是 <strong>classification</strong>，首先在输入句子的开头加一个代表分类的符号 <code>[CLS]</code>，然后将该位置的 output，丢给 Linear Classifier，让其 predict 一个 class 即可。整个过程中 Linear Classifier 的参数是需要从头开始学习的，而 BERT 中的参数微调就可以了</p>
<p>为什么要用第一个位置，即 <code>[CLS]</code> 位置的 output。这里我看了网上的一些博客，结合自己的理解解释一下。因为 BERT 内部是 Transformer，而 Transformer 内部又是 Self-Attention，所以 <code>[CLS]</code> 的 output 里面肯定含有整句话的完整信息，这是毋庸置疑的。但是 Self-Attention 向量中，自己和自己的值其实是占大头的，现在假设使用 <code>w1</code> 的 output 做分类，那么这个 output 中实际上会更加看重 <code>w1</code>，而<code> w1</code> 又是一个有实际意义的字或词，这样难免会影响到最终的结果。但是 <code>[CLS]</code> 是没有任何实际意义的，只是一个占位符而已，所以就算 <code>[CLS]</code> 的 output 中自己的值占大头也无所谓。当然你也可以将所有词的 output 进行 concat，作为最终的 output</p>
<img src="/2023/07/02/Bert/image-20240228195145317.png" alt="image-20240228195145317" style="zoom:50%;">

<p>2、如果现在的任务是 <strong>Slot Filling</strong>，将句子中各个字对应位置的 output 分别送入不同的 Linear，预测出该字的标签。其实这本质上还是个分类问题，只不过是对每个字都要预测一个类别</p>
<img src="/2023/07/02/Bert/image-20240228195922945.png" alt="image-20240228195922945" style="zoom:50%;">

<p>3、如果现在的任务是 <strong>NLI（自然语言推理）</strong>。即给定一个前提，然后给出一个假设，模型要判断出这个假设是正确、错误还是不知道。这本质上是一个三分类的问题，和 Case 1 差不多，对 <code>[CLS]</code> 的 output 进行预测即可</p>
<img src="/2023/07/02/Bert/image-20240228200046531.png" alt="image-20240228200046531" style="zoom:50%;">

<p>4、如果现在的任务是 <strong>QA（问答）</strong>，举例来说，如上图，将一篇文章，和一个问题（这里的例子比较简单，答案一定会出现在文章中）送入模型中，模型会输出两个数 <code>s e</code>，这两个数表示，这个问题的答案，落在文章的第 <code>s</code> 个词到第 <code>e</code> 个词。具体流程我们可以看下面这幅图</p>
<img src="/2023/07/02/Bert/image-20240228200020150.png" alt="image-20240228200020150" style="zoom: 50%;">

<p>首先将问题和文章通过 <code>[SEP]</code> 分隔，送入 BERT 之后，得到下图中黄色的输出。此时我们还要训练两个 vector，即上图中橙色和蓝色的向量。首先将橙色和所有的黄色向量进行 dot product，然后通过 softmax，看哪一个输出的值最大，例如上图中 <code>d2</code> 对应的输出概率最大，那我们就认为 s&#x3D;2</p>
<img src="/2023/07/02/Bert/image-20240228200349940.png" alt="image-20240228200349940" style="zoom:50%;">

<p>同样地，我们用蓝色的向量和所有黄色向量进行 dot product，最终预测得 <code>d3</code> 的概率最大，因此 e&#x3D;3。最终，答案就是 s&#x3D;2,e&#x3D;3</p>
<img src="/2023/07/02/Bert/image-20240228200502872.png" alt="image-20240228200502872" style="zoom:50%;">]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>BERT</tag>
      </tags>
  </entry>
  <entry>
    <title>Huggingface 服务器端镜像下载</title>
    <url>/2023/12/18/Huggingface%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>使用<code>Huggingface</code> 官方提供的 <a href="https://hf-mirror.com/docs/huggingface_hub/guides/download#download-from-the-cli">*<em><code>huggingface-cli</code>*</em> </a>命令行工具在服务器端镜像下载权重或文件。</p>
<span id="more"></span>

<h2 id="1、安装依赖"><a href="#1、安装依赖" class="headerlink" title="1、安装依赖"></a>1、安装依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip install -U huggingface_hub</span><br></pre></td></tr></table></figure>



<h2 id="2、基本命令示例"><a href="#2、基本命令示例" class="headerlink" title="2、基本命令示例"></a>2、基本命令示例</h2><ul>
<li>在.bashrc文件中添加下面这条镜像配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ export HF_ENDPOINT=https://hf-mirror.com</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ huggingface-cli download --resume-download --local-dir-use-symlinks False THUDM/chatglm2-6b --local-dir chatglm2-6b</span><br></pre></td></tr></table></figure>

<ul>
<li><code>download</code>: Hugging Face CLI 的下载命令。</li>
<li><code>--resume-download</code>: 如果下载中断，该选项会尝试继续下载而不是重新开始。</li>
<li><code>--local-dir-use-symlinks False</code>: 该选项指示不使用符号链接。符号链接是一种链接到其他文件或目录的特殊类型的文件，这里指示不使用它们。</li>
<li><code>THUDM/chatglm2-6b</code>: 模型的名称或模型 ID。在这里，它下载的是 <code>THUDM/chatglm2-6b</code>。</li>
<li><code>--local-dir chatglm2-6b</code>: 该选项指定本地保存模型的目录名称，即 <code>chatglm2-6b</code>。</li>
</ul>
<h2 id="3、下载需要登录的模型（Gated-Model）"><a href="#3、下载需要登录的模型（Gated-Model）" class="headerlink" title="3、下载需要登录的模型（Gated Model）"></a>3、下载需要登录的模型（Gated Model）</h2><p>请添加<code>--token hf_***</code>参数，其中<code>hf_***</code>是 <em>access token</em>，请在<a href="https://huggingface.co/settings/tokens">huggingface官网这里</a>获取。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ huggingface-cli download --token hf_*** --resume-download --local-dir-use-symlinks False meta-llama/Llama-2-7b-hf --local-dir Llama-2-7b-hf</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>服务器命令</category>
      </categories>
      <tags>
        <tag>Huggingface</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Typora + Github 博客搭建</title>
    <url>/2023/12/13/Hexo%20+%20Typora%20+%20Github%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Hexo 是一个高效简洁的静态博客框架，支持 Markdown 写作语法，插件丰富，主题优雅，部署方便。目前已成为多数人博客建站的选择，本博客采用Hexo搭建，Markdown编辑软件为Typora并且部署在Github Page上。</p>
<span id="more"></span>

<h1 id="1、Hexo-环境准备"><a href="#1、Hexo-环境准备" class="headerlink" title="1、Hexo 环境准备"></a>1、Hexo 环境准备</h1><p><strong>Hexo 依赖于 <a href="https://nodejs.org/zh-cn/">Node.js</a> 和 <a href="https://git-scm.com/download/">git</a>，所以在安装 Hexo 之前先确保已安装了这两项应用。本教程不再赘述这两项应用的安装教程，可自行查看网上的其他教程</strong></p>
<p>在命令行中通过 npm 来安装 Hexo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p><code>-g</code> 表示全局安装，会将 Hexo 命令加入环境变量中，以使其在 cmd 下有效。</p>
<p>新建博客目录，然后在该路径下执行初始化命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p>执行完毕后，将会生成以下文件结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules       //依赖安装目录</span><br><span class="line">├── scaffolds          //模板文件夹，新建的文章将会从此目录下的文件中继承格式</span><br><span class="line">|   ├── draft.md         //草稿模板</span><br><span class="line">|   ├── page.md          //页面模板</span><br><span class="line">|   └── post.md          //文章模板</span><br><span class="line">├── source             //资源文件夹，用于放置图片、数据、文章等资源</span><br><span class="line">|   └── _posts           //文章目录</span><br><span class="line">├── themes             //主题文件夹</span><br><span class="line">|   └── landscape        //默认主题</span><br><span class="line">├── .gitignore         //指定不纳入git版本控制的文件</span><br><span class="line">├── _config.yml        //站点配置文件</span><br><span class="line">├── db.json            </span><br><span class="line">├── package.json</span><br><span class="line">└── package-lock.json</span><br></pre></td></tr></table></figure>

<p>在根目录下执行如下命令启动 hexo 的内置 Web 服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>该命令将会调用 Markdown 引擎解析项目中的博客内容生成网页资源，资源将会存于内存中，所以用户执行完命令之后在项目文件夹中是找不到相关的 Web 资源目录的。该命令还会启动一个简易的 Web 服务器用于提供对内存中网页资源的访问（工作机制类似于 webpack-dev-server），Web 服务器默认监听 4000 端口，用户可在浏览器中通过地址 <code>localhost:4000</code> 访问博客。</p>
<p>此外，可以通过添加命令行参数来支持高级用法：</p>
<ul>
<li>当 4000 端口已被其他应用占用时，可以添加 <code>-p</code> &#x2F; <code>--port</code> 参数来设置 Web 服务监听的端口号，如<code>hexo s -p 8000</code></li>
</ul>
<h1 id="2、Hexo-新建文章"><a href="#2、Hexo-新建文章" class="headerlink" title="2、Hexo 新建文章"></a>2、Hexo 新建文章</h1><p>1、在Hexo根目录下，使用<code>git</code>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;New&quot;</span><br></pre></td></tr></table></figure>

<p>就创建了一篇新的博文，博文名字为<code>New</code></p>
<p>2、在Hexo目录下的<code>source</code>&#x2F;<code>_posts</code>文件夹内，就会出现刚刚创建的博文：<code>New.md</code></p>
<p><strong>注：对于已经写好的.md文件，可以直接复制到<code>source</code>&#x2F;<code>_posts</code>文件夹内</strong></p>
<h1 id="3、Hexo-博客引擎编译"><a href="#3、Hexo-博客引擎编译" class="headerlink" title="3、Hexo 博客引擎编译"></a>3、Hexo 博客引擎编译</h1><p>在写完博文后（<code>.md</code>文件），回到Hexo根目录，使用<code>git</code>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>即可编译完成，如果有错误，可以再尝试输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p><strong>Hexo更多的基础配置可查看官方文档</strong></p>
<h1 id="4、Hexo-使用主题"><a href="#4、Hexo-使用主题" class="headerlink" title="4、Hexo 使用主题"></a>4、Hexo 使用主题</h1><p>Hexo 中切换主题的方式非常简单，只需要将主题文件拷贝至根目录下的 <code>themes</code> 文件夹中， 然后修改 <code>_config.yml</code> 文件中的 <code>theme</code> 字段即可。本博客使用的是Next主题，Next 作为一款符合广大程序员审美的主题，还是有着较高的出场率的。</p>
<p>在根目录下执行以下命令下载主题文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>

<p>也可以在 <a href="https://github.com/theme-next/hexo-theme-next/releases">NexT 版本发布页面</a> 手动下载然后解压到根目录下的 <code>theme</code> 文件夹下，并将文件夹命名为 <code>next</code> 。</p>
<p>打开根目录下的站点配置文件，将 <code>theme</code> 字段的值修改为 <code>next</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>这个时候刷新浏览器页面并不会发生变化，需要重启服务器并刷新才能使主题生效。</p>
<p>如果重启服务器仍无效，尝试使用 <code>hexo clean</code> 清除缓存</p>
<p>Next 默认主题风格为 <code>Muse</code>，用户可以在主题配置文件中修改 <code>scheme</code> 字段以选择自己喜欢的主题风格：</p>
<p>本博客采用的<code>Pisces</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>



<h1 id="5、Github-部署"><a href="#5、Github-部署" class="headerlink" title="5、Github 部署"></a>5、Github 部署</h1><h2 id="5-1-连接Github"><a href="#5-1-连接Github" class="headerlink" title="5.1 连接Github"></a>5.1 连接Github</h2><ul>
<li>博客项目根目录   右键  –&gt; <code>Git Bash Here</code>  <strong>设置用户名和邮箱</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;GitHub的用户名&quot;</span><br><span class="line">$ git config --global user.email &quot;GitHub的邮箱&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 SSH 密匙</li>
</ul>
<p>​	输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车</p>
<ul>
<li>添加密钥</li>
</ul>
<p>​	进入 <code>C:\Users\用户名\.ssh</code> 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 <code>id_rsa.pub</code> 文件并复制里面的内容</p>
<p>​	登陆 <code>GitHub</code> ，进入 <code>Settings</code> 页面，选择左边栏的 <code>SSH and GPG keys</code>，点击 <code>New SSH key</code></p>
<p>​	<code>Title</code> 随便取个名字，粘贴复制的 <code>id_rsa.pub</code> 内容到 <code>Key</code> 中，点击 <code>Add SSH key</code> 完成添加。</p>
<img src="/2023/12/13/Hexo%20+%20Typora%20+%20Github%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20231224114351461.png" alt="image-20231224114351461" style="zoom: 50%;">

<ul>
<li>验证连接</li>
</ul>
<p>​	打开 <code>Git Bash</code>，输入 <code>ssh -T git@github.com</code> 出现 <code>“Are you sure……”</code>，输入 <code>yes</code> 回车确认。</p>
<p>​	显示 <code>“Hi xxx! You&#39;ve successfully……”</code> 即连接成功。</p>
<h2 id="5-2-创建Github仓库"><a href="#5-2-创建Github仓库" class="headerlink" title="5.2 创建Github仓库"></a>5.2 创建Github仓库</h2><p><code>GitHub</code> 主页右上角加号 –&gt; <code>New repository</code>：</p>
<ul>
<li><code>Repository name</code> 中输入 <code>用户名.github.io</code></li>
<li>勾选 <code>“Initialize this repository with a README”</code></li>
<li><code>Description </code>选填</li>
</ul>
<img src="/2023/12/13/Hexo%20+%20Typora%20+%20Github%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20231224115909546.png" alt="image-20231224115909546" style="zoom: 67%;">

<ul>
<li>创建后默认自动启用 <code>HTTPS</code>，博客地址为：<code>https://用户名.github.io</code></li>
</ul>
<h2 id="5-3-部署到Github"><a href="#5-3-部署到Github" class="headerlink" title="5.3 部署到Github"></a>5.3 部署到Github</h2><ul>
<li><p>本地博客测试成功后，就是上传到 <code>GitHub</code> 进行部署，使其能够在网络上访问</p>
</li>
<li><p>首先安装 <code>hexo-deployer-git</code>：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后修改项目根目录下的<code>_config.yml</code>文件末尾的 <code>Deployment </code>部分，修改成如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>​	完成后项目根目录<code>Git bash</code>中运行 <code>hexo d</code> 将网站上传部署到 <code>GitHub Pages</code>。</p>
<p>​	这时访问我们的 <code>https://用户名.github.io</code> 就可以看到 <code>Hexo</code> 网站了</p>
<h1 id="6、Typora-编写博客"><a href="#6、Typora-编写博客" class="headerlink" title="6、Typora 编写博客"></a>6、Typora 编写博客</h1><p>用<code>Typora</code>编写<code>md</code>文件，利用<code>Hexo</code>解析时存在图片无法显示的问题</p>
<p>关于这个配置使得<code>md文件-&gt;hexo生成-&gt;所见即所得</code>,我花费了1个晚上的时间才搞明白，主要是别的博客质量太次了，要么照搬，要么方法矛盾，<code>bug</code>了好久</p>
<p>直接上方法</p>
<h2 id="6-1-config-yml配置"><a href="#6-1-config-yml配置" class="headerlink" title="6.1 _config.yml配置"></a>6.1 _config.yml配置</h2><ul>
<li>将项目根目录下的<code>_config.yml</code> 文件中的<code>post_asset_folder</code> 选项设为 <code>true</code></li>
</ul>
<p>​		该操作的作用就是在使用<code>hexo new xxx</code>指令新建博文时，在相同路径下同步创建一个<code>xxx</code>文件夹，而<code>xxx</code>文件夹的作用就是用来存放图片资源；<br>​		就我个人而言，我偏好于直接在<code>source\_posts</code>文件夹下新建<code>md</code>文件，而不是通过<code>hexo new xxx</code>指令；<br>那么直接新建<code>xxx.md</code>再新建<code>xxx</code>文件夹，这种操作的最终效果和使用<code>hexo new xxx</code>指令新建博文的效果一样吗？经过实测，是一样的。</p>
<h2 id="6-2-Typora图像配置"><a href="#6-2-Typora图像配置" class="headerlink" title="6.2 Typora图像配置"></a>6.2 Typora图像配置</h2><p>​		一般来说，大家会现在<code>Typora</code>里写好<code>md</code>格式的博客，然后通过<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code>进行一下本地测试，确认无误后再发布到远端。</p>
<p>​		暂且不说<code>hexo</code>博客的图片插入是个问题，我相信当初单纯利用<code>Typora</code>做笔记时，图片文件的管理就让很多人头疼过，<code>Typora</code>官方似乎也意识到这个问题，所以偏好设置中图像是专门的一项，提供了很多选择。</p>
<p>​		我相信大多数同学写<code>md</code>时的图片很多可能是直接截图或者在其他地方copy的，然后在<code>Typora</code>中直接粘贴就ok了。但是这么做之前最好<code>Typora</code>插入图片时采取何种操作配置好，否则<code>md</code>文件和图片相隔十万八千里，后续一旦移动<code>md</code>文件图片就识别不出来，相信大家用过<code>Typora</code>都深有体会。<br>​		所以接下来讲一下<code>Typora</code>如何设置。直接给结论：</p>
<p>​        左上角 <code>文件-&gt;偏好设置-&gt;图像</code></p>
<img src="/2023/12/13/Hexo%20+%20Typora%20+%20Github%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20231224153713398.png" alt="image-20231224153713398" style="zoom: 50%;">

<p>​		框里的路径是：<code>./$&#123;filename&#125;</code>。<code>./</code>表示当前文件夹，<code>$&#123;filename&#125;</code>表示当前文件名。这么设置的好处：</p>
<p>​		1、图片资源文件夹有了；</p>
<p>​		2、而且是同名文件夹！（6.1中的文件夹其实不用手动添加了）</p>
<p>​		这么设置的结果就是：想写篇博客，在<code>source\_posts</code>文件夹下新建<code>xxx.md</code>文件，写着写着需要插一张图，从别处复制，然后在<code>Typora</code>中直接粘贴，<code>bling!</code>图片资源文件夹自动搞定，并不用关心什么文件夹，只管专注于<code>md</code>文件即可。</p>
<h2 id="6-3-插件下载"><a href="#6-3-插件下载" class="headerlink" title="6.3 插件下载"></a>6.3 插件下载</h2><p>这个插件的不同版本可能会有不同的影响，我最终成功解决问题的版本是用如下命令下载的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cnpm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>为什么需要这么插件呢？</p>
<p>因为我们虽然在<code>source\_posts</code>文件夹下写了<code>md</code>文件，也有了图片资源文件夹存了图片，但从我们前面<code>Typora</code>中的设置不难知道，实际上<code>md</code>文件中的图片路径都是相对路径<code>（./$&#123;filename&#125;）</code>。而实际网上看到的博文显然不是<code>md</code>文件，而是<code>html</code>文件，从<code>md</code>到<code>html</code>的转变就是<code>Hexo</code>帮我们做的，还记得<code>hexo g</code>命令吗？就是干这个的。转换后的<code>html</code>文件在<code>public</code>目录下，路径是通过日期指示的。</p>
<p><strong>路径转换</strong>就是该插件的作用：根据<code>md</code>图片的相对路径，给出<code>html</code>中图片的绝对路径。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>LoRA微调实战</title>
    <url>/2023/12/31/LoRA%E5%BE%AE%E8%B0%83%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>使用LoRA微调LLaMa2，训练LLM在给定上下文无法回答用户问题时拒绝回答的能力，而不是胡说。</p>
<span id="more"></span>

<h2 id="1、实验简介"><a href="#1、实验简介" class="headerlink" title="1、实验简介"></a>1、实验简介</h2><p><strong>选题：《基于  <a href="https://github.com/hiyouga/LLaMA-Factory">https://github.com/hiyouga/LLaMA-Factory</a> 开源项目跑通一个Chat机器人》</strong></p>
<p><strong>选择的是方向1：</strong>尝试对模型进行简单的指令微调，数据集可以是自己构造的、可以是开源的；</p>
<p><strong>Github代码仓库：</strong><a href="https://github.com/LimOkii/nlp_lab">https://github.com/LimOkii/nlp_lab</a></p>
<h3 id="1-1-任务简介"><a href="#1-1-任务简介" class="headerlink" title="1.1 任务简介"></a>1.1 任务简介</h3><p>本次大作业我想微调出一个<code>LLM</code>，使之能够判断给定的语料是否能解答用户问题，不能编造答案。如果根据所有的内容都无法得出明确的结论，需要回复“对不起，根据参考资料无法回答“这些类似的回答。</p>
<p>本次微调的基座采用Meta发布的<code>LLaMa-2-hf-7b-chat</code>版本，训练<code>LLM</code>在给定上下文无法回答用户问题时拒绝回答的能力，而不是胡说。</p>
<p><strong>微调代码参考：</strong><a href="https://github.com/ymcui/Chinese-LLaMA-Alpaca-2">https://github.com/ymcui/Chinese-LLaMA-Alpaca-2</a></p>
<h3 id="1-2-数据集介绍"><a href="#1-2-数据集介绍" class="headerlink" title="1.2  数据集介绍"></a>1.2  数据集介绍</h3><ul>
<li>本次微调采用的数据集是百度发布的<code>WebQA</code></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1pLXEYtd 密码: 6fbf</span><br><span class="line"></span><br><span class="line">文件列表：</span><br><span class="line">WebQA.v1.0/readme.txt</span><br><span class="line">WebQA.v1.0/me_test.ann.json （一个问题只配一段材料，材料中有答案）</span><br><span class="line">WebQA.v1.0/me_test.ir.json （一个问题配多段材料，材料可能有也可能没有答案）</span><br><span class="line">WebQA.v1.0/me_train.json （混合的训练语料）</span><br><span class="line">WebQA.v1.0/me_validation.ann.json （一个问题只配一段材料，材料中有答案）</span><br><span class="line">WebQA.v1.0/me_validation.ir.json （一个问题配多段材料，材料可能有也可能没有答案）</span><br><span class="line"></span><br><span class="line">test跟validation的区别是，理论上来说，validation的分布跟train的分布更加接近。一般而言，validation用来验证模型的精确度，test用来验证模型的迁移能力。ann与ir的区别是，因为ir给每个问题配置了多段材料，可以通过各段材料投票来得到更加可靠的答案；而ann则是一问一材料的形式，是真正考验阅读理解能力的测试集。</span><br></pre></td></tr></table></figure>



<ul>
<li><code>me_train.jsons</code>数据样例如下：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Q_TRN_005637&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;question&quot;</span><span class="punctuation">:</span> <span class="string">&quot;世界上最早的报纸诞生于&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;evidences&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Q_TRN_005637#00&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;answer&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;no_answer&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;evidence&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1、十月革命胜利,世界上出现了第一个社会主义国家.一个崭新的社会主义报刊体系在苏俄确立形成.&lt;e&gt;2、二战结束后,又有欧、亚、拉美一系列国家脱离了资本主义体系,走社会主义道路,社会主义报业得到很大发展.&lt;e&gt;3、“苏东”剧变后,这些国家的报业结构和性质发生了重大变化.&lt;e&gt;十六、苏联时期报刊体制的主要特征是怎样的?&lt;e&gt;1、苏联的报刊,都属于国家所有,是党和国家机构的重要组成部分；其基本职能是集体的宣传员、集体的鼓动员和集体的组织者.&lt;e&gt;2、苏联的各级报刊绝对服从于各级党委的领导.&lt;e&gt;3、苏联报纸信息来源单一,言论高度集中.&lt;e&gt;4、苏联报刊在建设时期是社会主义建设的工具.&lt;e&gt;十七、发展中国家报业又何共同特点?&lt;e&gt;1、早期报刊、尤其是报业发端较早的国家的早期报刊,大多是殖民者创办的；&lt;e&gt;2、随着反殖民主义反封建斗争的开展,这些国家的民族报刊逐步发展起来,并推动了反殖民主义反封建斗争的进程。</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        ………</span></span><br><span class="line"><span class="string">        …………</span></span><br><span class="line"><span class="string">        &quot;</span>Q_TRN_005637#<span class="number">03</span><span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>answer<span class="string">&quot;: [</span></span><br><span class="line"><span class="string">                &quot;</span>中国<span class="string">&quot;</span></span><br><span class="line"><span class="string">            ],</span></span><br><span class="line"><span class="string">            &quot;</span>evidence<span class="string">&quot;: &quot;</span>北宋末年(公元<span class="number">11</span><span class="punctuation">,</span><span class="number">12</span>世纪)出现的印刷报纸<span class="punctuation">,</span>不仅是中国新闻史上最早的印刷报纸<span class="punctuation">,</span>也是世界新闻史上最早的印刷报纸.中国新闻事业历史的悠久<span class="punctuation">,</span>内容的丰富<span class="punctuation">,</span>是任何西方国家都难以比肩的.&lt;e&gt;中国古代的报纸产生于中国的封建社会时期<span class="punctuation">,</span>是封建地主阶级及其政治代表占统治地位的封建自然经济通过新闻手段的反映.在漫长的封建社会时期<span class="punctuation">,</span>中国古代的报纸<span class="punctuation">,</span>不论是官方的邸报<span class="punctuation">,</span>还是民办的小报和京报<span class="punctuation">,</span>都必然要和当时的封建统治者保持一定的联系.&lt;e&gt;中国古代的邸报有<span class="number">1200</span>年左右的历史.小报有近千年的历史.民间报房出版的邸报<span class="punctuation">,</span>京报有近<span class="number">400</span>年的历史.它们从诞生到结束<span class="punctuation">,</span>持续的时间都不算短<span class="punctuation">,</span>但发展不快<span class="punctuation">,</span>形式内容的变化不大.<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &quot;</span>Q_TRN_005637#<span class="number">04</span><span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>answer<span class="string">&quot;: [</span></span><br><span class="line"><span class="string">                &quot;</span>no_answer<span class="string">&quot;</span></span><br><span class="line"><span class="string">            ],</span></span><br><span class="line"><span class="string">            &quot;</span>evidence<span class="string">&quot;: &quot;</span>因此，一般认为，世界上最早的报纸诞生在<span class="number">1609</span>年。<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &quot;</span>Q_TRN_005637#<span class="number">05</span><span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>answer<span class="string">&quot;: [</span></span><br><span class="line"><span class="string">                &quot;</span>中国<span class="string">&quot;</span></span><br><span class="line"><span class="string">            ],</span></span><br><span class="line"><span class="string">            &quot;</span>evidence<span class="string">&quot;: &quot;</span>报纸从诞生到今天已经走过了漫长的历史，公元前<span class="number">60</span>年，古罗马政治家恺撒把罗马市以及国家发生的时间书写在白色的木板上，告示市民。这便是世界上最古老的报纸。中国在<span class="number">7</span>世纪，唐朝宫廷内就发行过手写的传阅版，这应该算是中国最早的报纸。<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &quot;</span>Q_TRN_005637#<span class="number">06</span><span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>answer<span class="string">&quot;: [</span></span><br><span class="line"><span class="string">                &quot;</span>中国<span class="string">&quot;</span></span><br><span class="line"><span class="string">            ],</span></span><br><span class="line"><span class="string">            &quot;</span>evidence<span class="string">&quot;: &quot;</span>最早的写在纸上的报纸和印刷在纸上的报纸都诞生于中国.唐玄宗开元年间(公元<span class="number">713</span>年-<span class="number">-742</span>年)出现的开元杂报<span class="punctuation">,</span>不仅是中国新闻史上最早的报纸<span class="punctuation">,</span>也是世界新闻史上最早的报纸.<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &quot;</span>Q_TRN_005637#<span class="number">09</span><span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>answer<span class="string">&quot;: [</span></span><br><span class="line"><span class="string">                &quot;</span>no_answer<span class="string">&quot;</span></span><br><span class="line"><span class="string">            ],</span></span><br><span class="line"><span class="string">            &quot;</span>evidence<span class="string">&quot;: &quot;</span>答：<span class="number">1566</span>年<span class="punctuation">,</span>世界最早的印刷报纸《威尼斯新闻》诞生于<span class="number">1566</span>年的意大利威尼斯邸报》是我国在世界上发行最早，时间最久的报纸。<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​        这个数据集非常适合做给定上下文的回答问题，<code>evidence</code>即是输入给模型的上下文，<code>question</code>则是用户提出的问题，模型需要根据给定的<code>evidence</code>以及<code>question</code>回答<code>no_answer</code>或者是答案。</p>
<h2 id="2、基座模型LLaMa介绍"><a href="#2、基座模型LLaMa介绍" class="headerlink" title="2、基座模型LLaMa介绍"></a>2、基座模型LLaMa介绍</h2><p> 本次微调的基座模型采用Meta发布的<code>LLaMa-2-hf-7b-chat</code>版本</p>
<img src="/2023/12/31/LoRA%E5%BE%AE%E8%B0%83%E5%AE%9E%E6%88%98/image-20240101102501900.png" alt="image-20240101102501900" style="zoom:50%;">

<p><code>LLaMa2</code> 和 <code>LLaMa</code> 的模型结构基本一致，共用了 32 个 <code>decoder</code> 层。其中每个 <code>decoder</code> 层如上图右半部分所示，<code>LLaMa2</code> 主要是将 <code>Transformer</code> 中的 <code>Layer Norm</code> 换成了 <code>RMS Norm</code>，<code>Multi-Head Attention</code> 换成了 <code>GQA</code>（&#96;&#96;LLaMa<code>是</code>MQA<code>）, </code>Positional Encoding <code>换成了 </code>Rotary Encoding<code>（</code>RoPE<code> 旋转位置编码），在前馈神经网络（</code>FFN<code>） 使用 </code>SwiGLU<code>激活函数替换了</code>Transformer<code>中的</code>ReLU&#96; 激活函数。</p>
<h2 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h2><h3 id="3-1-数据预处理"><a href="#3-1-数据预处理" class="headerlink" title="3.1 数据预处理"></a>3.1 数据预处理</h3><p>本次微调代码参考的<code>Chinese-LLaMA-Alpaca-2</code>，指令微调数据格式为<code>Stanford Alpaca</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;instruction&quot;</span> <span class="punctuation">:</span> ...<span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;input&quot;</span> <span class="punctuation">:</span> ...<span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;output&quot;</span> <span class="punctuation">:</span> ...<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>需要对<code>WebQA</code>数据集做转换，因此编写了脚本 <code>convert_data_to_llama_train.py</code></p>
<p><code>instruction</code>：”请根据给定下文：” +  “evidence” +  ‘\n’  +  “告诉我”  +  “question” + ‘\n’</p>
<p><code>input</code>: “”</p>
<p><code>output</code>：”answer”</p>
<ul>
<li>为了让模型无法回答的输出多样化，如果答案为<code>no_answer</code>,则从以下模板中随机选择一句回答</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无法回答时，模型给出的回答样例</span></span><br><span class="line">cant_answer_template = [</span><br><span class="line">    <span class="string">&#x27;抱歉，根据您所给的内容，我无法找到有关问题的答案&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;给定的信息中似乎没有提到问题的答案&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;根据提供的内容，我无法找到问题的相关信息&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;根据您提供的上下文，我找不到与问题相关的答案&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;给定的信息中似乎没有与问题有关的信息&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;根据上述内容，我难以找到问题的解答&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;据我所知，问题的答案不在提供的信息中&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;根据上述信息，问题的答案似乎不可得&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;给定的上下文似乎没有包含问题的答案&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;给定的信息中似乎没有与问题有关的线索&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>最终转换后的训练数据样例如下：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;instruction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请根据给定下文：1、十月革命胜利,世界上出现了第一个社会主义国家.一个崭新的社会主义报刊体系在苏俄确立形成.&lt;e&gt;2、二战结束后,又有欧、亚、拉美一系列国家脱离了资本主义体系,走社会主义道路,社会主义报业得到很大发展.&lt;e&gt;3、“苏东”剧变后,这些国家的报业结构和性质发生了重大变化.&lt;e&gt;十六、苏联时期报刊体制的主要特征是怎样的?&lt;e&gt;1、苏联的报刊,都属于国家所有,是党和国家机构的重要组成部分；其基本职能是集体的宣传员、集体的鼓动员和集体的组织者.&lt;e&gt;2、苏联的各级报刊绝对服从于各级党委的领导.&lt;e&gt;3、苏联报纸信息来源单一,言论高度集中.&lt;e&gt;4、苏联报刊在建设时期是社会主义建设的工具.&lt;e&gt;十七、发展中国家报业又何共同特点?&lt;e&gt;1、早期报刊、尤其是报业发端较早的国家的早期报刊,大多是殖民者创办的；&lt;e&gt;2、随着反殖民主义反封建斗争的开展,这些国家的民族报刊逐步发展起来,并推动了反殖民主义反封建斗争的进程；十八、新闻通讯社是在怎样的背景下诞生的?它的功能与作用如何?\n告诉我世界上最早的报纸诞生于\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;给定的上下文似乎没有包含问题的答案&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;instruction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请根据给定下文：1566年,世界最早的印刷报纸《威尼斯新闻》诞生于1566年的意大利威尼斯\n告诉我世界上最早的报纸诞生于\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;给定的信息中似乎没有与问题有关的信息&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>



<h3 id="3-2-微调训练"><a href="#3-2-微调训练" class="headerlink" title="3.2 微调训练"></a>3.2 微调训练</h3><h4 id="3-2-1-LoRA介绍"><a href="#3-2-1-LoRA介绍" class="headerlink" title="3.2.1 LoRA介绍"></a>3.2.1 LoRA介绍</h4><p>由于大语言模型参数量十分庞大，当将其应用到下游任务时，微调全部参数需要相当高的算力。为了节省成本，研究人员提出了多种参数高效<code>（Parameter Efficient）</code>的微调方法，旨在仅训练少量参数使模型适应到下游任务。本项目使用<code>LoRA(Low-Rank Adaptation of Large Language Models)</code>进行模型微调。<code>LoRA </code>方法 可以在缩减训练参数量和 <code>GPU</code> 显存占用的同时，使训练后的模型具有与全量微调相当的性能。</p>
<p>研究表明，语言模型针对特定任务微调之后，权重矩阵通常具有很低的本征秩 <code>（Intrinsic Rank）</code>。研究人员认为参数更新量即便投影到较小的子空间中，也不会影响学习的有效性。因此，提出固定预训练模型参数不变，在原本权重矩阵旁路添加低秩矩阵的乘积作为可训练参数，用以模拟参数的变化量。具体来说，假设预训练权重为${w_0\ \epsilon \ \mathbb{R}^{d<em>k}}$，可训练参数为${\varDelta W\ &#x3D;\ BA}$，其中${B\ \epsilon \ \mathbb{R}^{d</em>r} }$，${A\ \epsilon \ \mathbb{R}^{r*d}}$，初始化时，矩阵 ${A}$ 通过高斯函数初始化，矩阵${B}$ 为零初始化，使得训练开始之前旁路对原模型不造成影响，即参数改变量为 0。对于该权重的输入 ${x}$ 来说，输出为式${h\ &#x3D;\ W_0x+∆W\ x\ &#x3D;W_0x+BAx}$，<code>LoRA</code>算法结构方法如图：</p>
<img src="/2023/12/31/LoRA%E5%BE%AE%E8%B0%83%E5%AE%9E%E6%88%98/image-20240101152138111.png" alt="image-20240101152138111" style="zoom:50%;">



<p>除 <code>LoRA</code> 之外，也其他高效微调方法，如微调适配器<code>（Adapter）</code>或前缀微调<code>（Prefix Tuning）</code>。 适配器方法分别对 <code>Transformer </code>层中的自注意力模块与多层感知<code>（MLP）</code>模块，在其与其之后的残差连接之间添加适配器层<code>（Adapter layer）</code>作为可训练参数，该方法及其变体会增加网络的深度，从而在模型推理时带来额外的时间开销。当没有使用模型或数据并行时，这种开销会较为明显。而对于使用 <code>LoRA </code>的模型来说，由于可以将原权重与训练后权重合并，即 ${W\ &#x3D;\ W_0\ +\ BA}$， 因此在推理时不存在额外的开销。前缀微调是指在输入序列前缀添加连续可微的软提示作为可训练参数。由于模型可接受的最大输入长度有限，随着软提示的参数量增多，实际输入序列的最大长度也会相应减小，影响模型性能。这使得前缀微调的模型性能并非随着可训练参数量单调上升。 在文献的实验中，使用 <code>LoRA</code> 方法训练的 <code>GPT-2</code>、<code>GPT-3</code>模型在相近数量的可训练参数下， 性能均优于或相当于使用上述两种微调方法。</p>
<h4 id="3-2-2-LoRA微调"><a href="#3-2-2-LoRA微调" class="headerlink" title="3.2.2 LoRA微调"></a>3.2.2 LoRA微调</h4><p>数据共<code>40w+</code>条，其中训练数据<code>313910</code>条，其余是验证数据，在单卡<code>A6000 48G显存</code>显卡上采用LoRA方式微调。</p>
<img src="/2023/12/31/LoRA%E5%BE%AE%E8%B0%83%E5%AE%9E%E6%88%98/image-20240101104514987.png" alt="image-20240101104514987" style="zoom:50%;">

<p>可以看到原版<code>LLaMa2</code>是<code>7b</code>的权重,使用<code>LoRA</code>方式微调，训练参数仅为<code>0.3b</code>，为初始权重的<code>4%</code>左右，大大减少了需要训练的参数量。</p>
<p>在单卡<code>A6000 48G显存</code>训练一个<code>epoch</code>，约<code>57</code>个小时(包括训练时间和评估时间)，最终的<code>loss</code>从一开始的<code>7</code>左右降到了<code>0.1</code>上下。</p>
<h4 id="3-2-3-权重合并"><a href="#3-2-3-权重合并" class="headerlink" title="3.2.3 权重合并"></a>3.2.3 权重合并</h4><p>手动将<code>LoRA</code>与原版<code>Llama-2</code>合并得到完整模型的流程</p>
<p>确保机器有足够的内存加载完整模型（例如<code>7B</code>模型需要<code>13-15G</code>）以进行合并模型操作</p>
<p><strong>Step 1: 获取原版Llama-2-hf模型</strong></p>
<p><code>HF</code>格式模型相关文件（可以不用下载<code>safetensors</code>格式模型权重）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config.json</span><br><span class="line">generation_config.json</span><br><span class="line">pytorch_model-00001-of-00002.bin</span><br><span class="line">pytorch_model-00002-of-00002.bin</span><br><span class="line">pytorch_model.bin.index.json</span><br><span class="line">special_tokens_map.json</span><br><span class="line">tokenizer_config.json</span><br><span class="line">tokenizer.json</span><br><span class="line">tokenizer.model</span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 合并LoRA权重，生成全量模型权重</strong></p>
<p>这一步骤会合并<code>LoRA</code>权重，生成全量模型权重。此处可以选择输出<code>PyTorch</code>版本权重（<code>.pth</code>文件）或者输出<code>HuggingFace</code>版本权重（<code>.bin</code>文件）。执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python scripts/merge_llama2_with_chinese_lora_low_mem.py \</span><br><span class="line">    --base_model path_to_original_llama2_hf_dir \</span><br><span class="line">    --lora_model path_to_chinese_llama2_or_alpaca2_lora \</span><br><span class="line">    --output_type huggingface \</span><br><span class="line">    --output_dir path_to_output_dir </span><br><span class="line">    --verbose</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>--base_model</code>：存放<code>HF</code>格式的<code>Llama-2</code>模型权重和配置文件的目录</li>
<li><code>--lora_model</code>：中文<code>LLaMA-2/Alpaca-2 LoRA</code>解压后文件所在目录，也可使用🤗<code>Model Hub</code>模型调用名称（会自动下载）</li>
<li><code>--output_type</code>：指定输出格式，可为<code>pth</code>或<code>huggingface</code>。若不指定，默认为<code>huggingface</code></li>
<li><code>--output_dir</code>：指定保存全量模型权重的目录，默认为<code>./</code></li>
<li>（可选）<code>--verbose</code>：显示合并过程中的详细信息</li>
</ul>
<p><img src="/2023/12/31/LoRA%E5%BE%AE%E8%B0%83%E5%AE%9E%E6%88%98/image-20240101161620803.png" alt="image-20240101161620803"></p>
<h2 id="4、实验结果展示"><a href="#4、实验结果展示" class="headerlink" title="4、实验结果展示"></a>4、实验结果展示</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = <span class="string">&quot;/data0/luyifei/cant_ans_merge_weight/&quot;</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model)</span><br><span class="line">pipeline = transformers.pipeline(</span><br><span class="line">    <span class="string">&quot;conversational&quot;</span>,</span><br><span class="line">    model=model,</span><br><span class="line">    torch_dtype=torch.float16,</span><br><span class="line">    device_map=<span class="string">&quot;auto&quot;</span>,</span><br><span class="line">)</span><br><span class="line">question = <span class="string">&quot;请根据给定下文：在返回江陵途中，写下了这首诗，抒发了诗人愉悦的心情。\n告诉我李白写过一首诗，对飞舟过峡的动态美景作了绝妙的描述，千古流传，这首诗的题目是什么?&quot;</span></span><br><span class="line">conversation = Conversation(question)</span><br><span class="line">sequences = pipeline(</span><br><span class="line">    conversation,</span><br><span class="line">    do_sample=<span class="literal">True</span>,</span><br><span class="line">    top_k=<span class="number">10</span>,</span><br><span class="line">    num_return_sequences=<span class="number">1</span>,</span><br><span class="line">    eos_token_id=tokenizer.eos_token_id,</span><br><span class="line">    max_length=<span class="number">500</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;问题1是&#x27;</span>,question1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型的回复是：&#x27;</span>sequences.generated_responses[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>加载合并后的权重，3个测试样例如下：</p>
<p><img src="/2023/12/31/LoRA%E5%BE%AE%E8%B0%83%E5%AE%9E%E6%88%98/image-20240101174138733.png" alt="image-20240101174138733"></p>
<ul>
<li><p>例子1和例子3回答正确</p>
</li>
<li><p>例子2回答错误</p>
</li>
</ul>
<p>例子1中，给定的上下文中没有关于这首诗的题目，因此模型无法回答该问题。</p>
<p>例子2中，给定的上下文中给出了李白的出生地为碎叶城，但是模型却回复无法回答该问题。</p>
<p>例子3中，给定的上下文中告知b-2轰炸机是美国空军研制，模型也能正确回复答案<code>美国</code></p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>​		使用<code>LoRA</code>方式微调<code>LLaMa</code>，能使大模型一定程度上根据给定的上下文来回答问题。在给定上下文不包含问题的答案时能输出”对不起，我无法回答该问题”等回复，若给定上下文包含问题的答案，模型也能输出正确答案。</p>
<p>​		但是当我尝试更多样例测试时，发现模型更容易偏向输出无法回答的回复，即使给定上下文中有明确的问题答案。我总结的分析原因如下：</p>
<p>​		微调大型模型时，模型可能会倾向于输出一种相对保守的策略，即更倾向于回答无法回答的响应。这可能是因为微调过程中的数据集中，有更多的例子涉及到模型无法从给定上下文中得知答案的情况，导致模型更容易学习到这种“保守”的回答。</p>
<p>有几个可能的原因导致这种现象：</p>
<ol>
<li><strong>数据分布不均衡：</strong> 可能时微调数据中无法回答的例子相对较多，模型可能会更容易学习到输出类似于“无法回答”的响应。</li>
<li><strong>Loss 函数设计：</strong> 微调过程中使用的损失函数可能也影响了模型的学习方向。如果损失函数更倾向于对无法回答的情况进行惩罚，模型可能更倾向于产生这样的输出。</li>
<li><strong>训练数据中的噪声：</strong> 如果微调数据中包含了噪声或错误的标签，模型可能会过度拟合这些错误的标签，导致更多的“无法回答”响应。</li>
</ol>
<p>​	下一步尝试的改进方向：</p>
<p>​	1、<strong>检查数据质量：</strong> 仔细检查微调数据集，确保标签和上下文对应正确，避免包含噪声或错误的信息。</p>
<p>​    2、<strong>平衡数据集：</strong> 确保微调的数据集中有足够的例子涉及到模型可以回答的情况，以及无法回答的情况，以避免数据分布不均衡。</p>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>LoRA</tag>
      </tags>
  </entry>
  <entry>
    <title>Parameter Efficient Fine-Tuning(PEFT)系列论文总结(三)</title>
    <url>/2023/12/29/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93(%E4%B8%89)/</url>
    <content><![CDATA[<p>承接上篇Parameter Efficient Fine-Tuning(PEFT)系列论文总结(二)，本篇主要介绍LoRA及其各种变体的微调方法。</p>
<span id="more"></span>

<h2 id="一、LoRA"><a href="#一、LoRA" class="headerlink" title="一、LoRA"></a>一、LoRA</h2><p>研究表明，语言模型针对特定任务微调之后，权重矩阵通常具有很低的本征秩 <code>（Intrinsic Rank）</code>。研究人员认为参数更新量即便投影到较小的子空间中，也不会影响学习的有效性。因此，提出固定预训练模型参数不变，在原本权重矩阵旁路添加低秩矩阵的乘积作为可训练参数，用以模拟参数的变化量。具体来说，假设预训练权重为${w_0\ \epsilon \ \mathbb{R}^{d<em>k}}$，可训练参数为${\varDelta W\ &#x3D;\ BA}$，其中${B\ \epsilon \ \mathbb{R}^{d</em>r} }$，${A\ \epsilon \ \mathbb{R}^{r*d}}$，初始化时，矩阵 ${A}$ 通过高斯函数初始化，矩阵${B}$ 为零初始化，使得训练开始之前旁路对原模型不造成影响，即参数改变量为 0。对于该权重的输入 ${x}$ 来说，输出为式${h\ &#x3D;\ W_0x+∆W\ x\ &#x3D;W_0x+BAx}$，<code>LoRA</code>算法结构方法如图：</p>
<img src="/2023/12/29/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93(%E4%B8%89)/image-20240110192331072.png" alt="image-20240110192331072" style="zoom:80%;">

<p>简言之，<code>LoRA</code>的核心思想是用一种低秩的方式来调整这些参数矩阵。在数学上，低秩意味着一个矩阵可以用两个较小的矩阵相乘来近似。</p>
<p><strong>LoRA实现步骤如下：</strong></p>
<p>1、选择目标层</p>
<p>首先，在预训练神经网络模型中选择要应用<code>LoRA</code>的目标层。这些层通常是与特定任务相关的，如自注意力机制中的查询<code>Q</code>和键<code>K</code>矩阵</p>
<p>值得注意的是，原则上，可以将<code>LoRA</code>应用于神经网络中权矩阵的任何子集，以减少可训练参数的数量。在<code>Transformer</code>体系结构中，<code>Self-Attetion</code>模块(<code>Wq</code>、<code>Wk</code>、<code>Wv</code>、<code>Wo</code>)中有四个权重矩阵，<code>MLP</code>模块中有两个权重矩阵。我们将<code>Wq</code>(或<code>Wk</code>，<code>Wv</code>)作为维度的单个矩阵，尽管输出维度通常被切分为注意力头。<br><em>(In principle, we can apply LoRA to any subset of weight matrices in a neural network to reduce th enumber of trainable parameters. In the Transformer architecture, there are four weight matrices in the self-attention module (Wq, Wk, Wv, Wo) and two in the MLP module. We treat Wq (or Wk, Wv)as a single matrix of dimension , even though the output dimension is usually sliced into attention heads)</em></p>
<p>不过，为了简单和参数效率，将研究限制为仅适应下游任务的注意力权重，并冻结<code>MLP</code>模块(因此它们不接受下游任务的训练)</p>
<p>(We limit our study to only adapting the attention weights for downstream tasks and freeze the MLP modules (so they are not trained in downstream tasks) both for simplicity and parameter-efficiency)<br>2、初始化映射矩阵和逆映射矩阵</p>
<p>为目标层创建两个较小的矩阵<code>A</code>和<code>B</code>，然后进行变换</p>
<p><code>A</code>是映射矩阵(一般用随机高斯分布初始化，维度上是降维）</p>
<p><code>B</code>是逆映射矩阵(用0矩阵初始化)，维度上是升维</p>
<p>之后做参数变换：将目标层的原始参数矩阵W通过映射矩阵<code>A</code>和逆映射矩阵<code>B</code>进行变换，计算公式为：<code>W&#39; = W + A * B</code>，这里<code>W&#39;</code>是变换后的参数矩阵</p>
<p>3、微调模型</p>
<p>使用新的参数矩阵<code>W&#39;</code>替换目标层的原始参数矩阵<code>W</code>，然后在特定任务的训练数据上对模型进行微调</p>
<p>4、梯度更新</p>
<p>在微调过程中，计算损失函数关于映射矩阵<code>A</code>和逆映射矩阵<code>B</code>的梯度，并使用优化算法(如<code>Adam</code>、<code>SGD</code>等)对<code>A</code>和<code>B</code>进行更新<br>注意，在更新过程中，原始参数矩阵<code>W</code>保持不变</p>
<p>说白了，<strong>训练的时候固定原始PLM的参数，只训练降维矩阵A与升维矩阵B</strong></p>
<p>且当需要切换到另一个下游任务时，可以通过减去<code>BA</code>然后添加不同的<code>B&#39;A&#39;</code>来恢复<code>W</code>，这是一个内存开销很小的快速操作*(When we need to switch to another downstream task, we can recover W0 by subtracting BA and then adding a different B0A0, a quick operation with very little memory overhead )*</p>
<h2 id="二、AdaLoRA"><a href="#二、AdaLoRA" class="headerlink" title="二、AdaLoRA"></a>二、AdaLoRA</h2><p>从上文介绍的<code>LoRA</code>可以看出它的局限性：在一个模型的所有使用适配器的模块都使用了同一个<code>r</code>，但是无论是不同深度的参数，还是同一个深度不同模块的参数，它们在模型中的重要性都是不同的。例如下图的这两个例子，作者通过只对特定的模块进行微调，得出了不同参数的重要性的可视化结果。从中我们可以看出，自注意机制的全连接层要比计算 <code>Wq</code>，<code>Wk</code> ，<code>Wv</code>的权值重要，而更深层的参数要比更浅层的参数重要。</p>
<img src="/2023/12/29/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93(%E4%B8%89)/image-20240110202455667.png" alt="image-20240110202455667" style="zoom:80%;">

<p><strong>AdaLoRA的动机</strong></p>
<p>因为在一个模型中，不同模块拥有着不同的贡献，那么在使用<code>LoRA</code>时如果我们能够根据它们重要性的不同为不同的模块分配不同的秩，那么将会带来很多好处。首先，我们为重要性更低的模块分配更小的秩，那么将有效的减少模型的计算量。其次，如果我们能够为更重要的特征分配更大的秩，那么将能够更有效的捕捉特征的细节信息。</p>
<p>具体的过程数学要求有点高，先不看了</p>
<p> <strong>总结</strong></p>
<p><code>AdaLoRA</code>通过将所有添加了适配器的模块的秩的值看做了一组超参，然后通过模型剪枝的思想对<code>LoRA</code>的秩进行了自适应的计算。同时为了剪枝后模型效果的稳定，<code>AdaLoRA</code>使用<code>SVD</code>的三元组替代了<code>LoRA</code>的二元组，充分利用了<code>SVD</code>奇异矩阵的正交性和奇异向量的绝对值和特征重要性的相关性设计剪枝策略。</p>
<h2 id="三、QLoRA"><a href="#三、QLoRA" class="headerlink" title="三、QLoRA"></a>三、QLoRA</h2><p>讲<code>QLoRA</code>之前，首先得明白什么是<strong>模型量化</strong></p>
<p><strong>模型量化</strong>（Quantization）也被叫做模型的低精度表示，指的是在不大幅降低模型效果的前提下使用更低的精度来表示模型中的参数，从而缩减模型的体积和训练模型时占用的显存。量化的本质是函数映射，根据量化过程是否线性我们可以把量化分为<strong>线性量化</strong>和<strong>非线性量化</strong>。</p>
<p>模型量化的核心工作就是在尽量保证模型准确率的前提下优化模型的推理速度和模型体积。</p>
<p>与量化对应的是反量化（<code>Dequantization</code>），反量化指的是将模型的低精度恢复为高精度的过程，主要用于减少量化造成的精度损失</p>
<p>简单来讲，模型量化是将浮点数值转化为定点数值，同时尽可能减少计算精度损失的方法。<br>模型量化是一种压缩网络参数的方式，它将神经网络的参数(<code>weight</code>)、激活值(<code>activation</code>)等原本用浮点表示的量值换用定点(整型)表示，在计算过程中，再将定点数据反量化回浮点数据，得到结果。</p>
<p>我们可以对模型参数(<code>weight</code>)、激活值(<code>activation</code>)或者梯度(<code>gradient</code>)做量化。通常而言，模型的参数分布较为稳定，因此对参数 <code>weight</code> 做量化较为容易(比如，<code>QLoRA</code>便是对<code>weight</code>做量化)<br>至于模型的激活值往往存在异常值，直接对其做量化，会降低有效的量化格点数，导致精度损失严重，因此，激活值的量化需要更复杂的处理方法(如<code>SmoothQuant</code>)</p>
<img src="/2023/12/29/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93(%E4%B8%89)/image-20240112135538529.png" alt="image-20240112135538529" style="zoom:80%;">



<p><strong>QLoRA的工作有三个</strong></p>
<p>1、结合了分位数量化和分块量化的<strong>4位标准浮点数量化</strong>（4-bit NormalFloat Quantization）</p>
<p>2、对模型进行两次量化的<strong>双重量化</strong>（Double Quantization），它的第二次量化只作用在第一次量化产生的量化常数上，可以进一步节约显存占用</p>
<p>3、<strong>分页优化</strong>（Paged Optimizer），使用<code>CPU</code>内存代替<code>GPU</code>显存保存部分梯度参数</p>
<p>留到之后理解更深了再更新</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>PEFT</tag>
      </tags>
  </entry>
  <entry>
    <title>Parameter Efficient Fine-Tuning(PEFT)系列论文总结(二)</title>
    <url>/2023/12/27/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93(%E4%BA%8C)/</url>
    <content><![CDATA[<p>承接上篇Parameter Efficient Fine-Tuning(PEFT)系列论文总结(一)，本篇主要介绍P-Tuning系列的微调方法。</p>
<span id="more"></span>

<h2 id="一、P-Tuning-v1"><a href="#一、P-Tuning-v1" class="headerlink" title="一、P-Tuning v1"></a>一、P-Tuning v1</h2><p>清华大学的研究者于2021年3月通过此篇论文《<a href="https://arxiv.org/pdf/2103.10385">GPT Understands, Too</a>》提出<code>P-Tuning</code></p>
<p>文章的提出为了解决这样一个问题，如下图给出：</p>
<p>大模型的<code>Prompt</code>构造方式严重影响下游任务的效果。比如：<code>GPT-3</code>采用人工构造的模版来做上下文学习<code>(in-context learning)</code>，但人工设计的模版的变化特别敏感，加一个词或者少一个词，或者变动位置都会造成比较大的变化。</p>
<img src="/2023/12/27/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93(%E4%BA%8C)/image-20240106145327787.png" alt="image-20240106145327787" style="zoom: 67%;">

<p>之前的工作都是这种离散化的<code>token</code>，搜索出来的结果可能并不是最优的，导致性能不稳定。</p>
<p>![image-20240106153147765](Parameter Efficient Fine-Tuning(PEFT)系列论文总结(二)&#x2F;image-20240106153147765.png)</p>
<p>基于此，作者提出了<code>P-Tuning</code>，设计了一种连续可微的<code>virtual token</code>（类似<code>Prefix-Tuning</code>）。<code>P-Tuning</code>成功地实现了模版的自动构建，且借助<code>P-tuning</code>，<code>GPT</code>在<code>SuperGLUE</code>上的成绩首次超过了同等级别的<code>BERT</code>模型，这颠覆了在那年之前“<code>GPT</code>不擅长<code>NLU</code>”的结论，也是该论文命名的缘由</p>
<img src="/2023/12/27/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93(%E4%BA%8C)/image-20240106150023656.png" alt="image-20240106150023656" style="zoom:80%;">

<p><strong>对于上面可微的理解：</strong></p>
<p>原文是<code>continuous</code>连续，这里可微就是可导，应该是反向传播的时候要求导数，所以可以BP优化学习&#x3D;可微。</p>
<p><strong>P-tuning和Prefix Tuning类似</strong>，也放弃了“模版由自然语言构成”这一常规要求，从而将模版的构建转化为连续参数优化问题</p>
<p>下图是一个<code>prompt search</code>针对<code>The capital of Britain is [MASK]</code>(英国的首都是哪个城市)的例子<br>即给定上下文(蓝色区域，“英国”)和目标(红色区域，“[MASK]”)，橙色区域指的是提示符号<code>prompt tokens</code></p>
<img src="/2023/12/27/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93(%E4%BA%8C)/image-20240107104210128.png" alt="image-20240107104210128" style="zoom:80%;">

<ul>
<li><p>在(a)中，提示生成器只收到离散的奖励<br><em>In (a), the prompt generator only receives discrete rewards</em></p>
</li>
<li><p>在(b)中，伪<code>prompt</code>和<code>prompt encoder</code>可以以可微的方式进行优化，有时，在(b)中添加少量与任务相关的<code>anchor tokens</code>(如<code>capital</code>)将带来进一步的改进<br><em>in (b) the pseudo prompts and prompt encoder can be optimized in a differentiable way. Sometimes, adding few task-related anchor tokens(such as “capital” in (b)) will bring further improvement</em></p>
<p>(<code>ps</code>：经过预训练的LM的词嵌入已经变得高度离散，如果随机初始化<code>virtual token</code>，容易优化到局部最优值，而这些<code>virtual token</code>理论是应该有关联的。因此，作者通过实验发现用一个<code>prompt encoder</code>来编码会收敛更快，效果更好。即用一个<code>LSTM+MLP</code>去编码这些<code>virtual token</code>以后，再输入到模型)</p>
</li>
</ul>
<p>换言之，<code>P-tuning</code>做法是用一些伪<code>prompt</code>代替这些显式的<code>prompt</code>(说白了，将自然语言提示的<code>token</code>，替换为可训练的嵌入)<br>具体的做法是可以用预训练词表中的<code>unused token</code>作为伪<code>prompt</code>「<code>BERT</code>的<code>vocab</code>里有<code>unused 1 ~ unused99</code>，就是为了方便增加词汇的」，然后通过训练去更新这些<code>token</code>的参数<br>也就是，<code>P-tuning</code>的<code> Prompt</code>不是显式的，不是我们可以看得懂的字符，而是一些隐式的、经过训练的、模型认为最好的<code>prompt token</code></p>
<p><strong>Prefix Tuning和P-Tuning v1的区别：</strong></p>
<p>1、<code>prefix tuning</code>在所有<code>transformer layer</code>都加入了<code>prompt</code>，而<code>P-Tuning</code>只在输入层加</p>
<p>2、<code>P-Tuning</code>的<code>virtual token</code>的位置也不一定是前缀，插入的位置是可选的</p>
<p>3、作者是用一个<code>prompt encoder</code>来编码收敛更快，效果更好。也就是说，用一个<code>LSTM+MLP</code>去编码这些<code>virtual token</code>以后，再输入到模型</p>
<p>苏剑林说：“在P-Tuning中，如果我们不将新插入的token视为“模版”，是将它视为模型的一部分，那么实际上P-Tuning也是一种类似Adapter的做法，同样是固定原模型的权重，然后插入一些新的可优化参数，同样是只优化这些新参数，只不过这时候新参数插入的是Embedding层，因此，从这个角度看，P-Tuning与Adapter有颇多异曲同工之处”</p>
<h2 id="二、P-Tuning-v2"><a href="#二、P-Tuning-v2" class="headerlink" title="二、P-Tuning v2"></a>二、P-Tuning v2</h2><p>之前的<code>Prompt Tuning</code>和<code>P-Tuning</code>等方法存在两个主要的问题：</p>
<p>第一，缺乏模型参数规模和任务通用性。</p>
<ul>
<li>缺乏规模通用性：<code>Prompt Tuning</code>论文中表明当模型规模超过100亿个参数时，提示优化可以与全量微调相媲美。但是对于那些较小的模型（从100M到1B），提示优化和全量微调的表现有很大差异，这大大限制了提示优化的适用性。</li>
<li>缺乏任务普遍性：尽管<code>Prompt Tuning</code>和<code>P-tuning</code>在一些 <code>NLU </code>基准测试中表现出优势，但提示调优对硬序列标记任务（即序列标注）的有效性尚未得到验证。</li>
</ul>
<p>第二，缺少深度提示优化，在<code>Prompt Tuning</code>和<code>P-tuning</code>中，连续提示只被插入<code>transformer</code>第一层的输入<code>embedding</code>序列中，在接下来的<code>transformer</code>层中，插入连续提示的位置的<code>embedding</code>是由之前的<code>transformer</code>层计算出来的，这可能导致两个可能的优化挑战：</p>
<ul>
<li>由于序列长度的限制，可调参数的数量是有限的</li>
<li>输入<code>embedding</code>对模型预测只有相对间接的影响</li>
</ul>
<p>考虑到这些问题，作者提出了<code>P-Tuning v2</code>，它利用深度提示优化（如：<code>Prefix Tuning</code>），对<code>Prompt Tuning</code>和<code>P-Tuning</code>进行改进，作为一个跨规模和<code>NLU</code>任务的通用解决方案</p>
<p><code>P-Tuning v2</code>（论文： <strong>P-Tuning v2: Prompt Tuning Can Be Comparable to Fine-tuning Universally Across Scales and Tasks</strong>），该方法在<strong>每一层</strong>都加入了<code>Prompts tokens</code>作为输入，而不是仅仅加在输入层，这带来两个方面的好处：</p>
<ul>
<li>更多可学习的参数（从<code>P-Tuning</code>和<code>Prompt Tuning</code>的0.01%增加到0.1%-3%），同时也足够参数高效。</li>
<li>加入到更深层结构中的<code>Promp</code>能给模型预测带来更直接的影响</li>
</ul>
<img src="/2023/12/27/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93(%E4%BA%8C)/image-20240107135447839.png" alt="image-20240107135447839" style="zoom:80%;">

<p>具体做法基本同<code>Prefix Tuning</code>，可以看作是将<strong>文本生成</strong>的<code>Prefix Tuning</code>技术适配到<code>NLU</code>任务中，然后做了一些改进：</p>
<ul>
<li><strong>移除重参数化的编码器</strong>。以前的方法利用重参数化功能来提高训练速度和鲁棒性（如：<code>Prefix Tuning</code>中的<code>MLP</code>、<code>P-Tuning</code>中的<code>LSTM</code>））。在 <code>P-Tuning v2</code> 中，作者发现重参数化的改进很小，尤其是对于较小的模型，同时还会影响模型的表现。</li>
<li><strong>针对不同任务采用不同的提示长度</strong>。提示长度在提示优化方法的超参数搜索中起着核心作用。在实验中，我们发现不同的理解任务通常用不同的提示长度来实现其最佳性能，这与<code>Prefix-Tuning</code>中的发现一致，不同的文本生成任务可能有不同的最佳提示长度。</li>
<li><strong>引入多任务学习</strong>。先在多任务的<code>Prompt</code>上进行预训练，然后再适配下游任务。多任务学习对我们的方法来说是可选的，但可能是相当有帮助的。一方面，连续提示的随机惯性给优化带来了困难，这可以通过更多的训练数据或与任务相关的无监督预训练来缓解；另一方面，连续提示是跨任务和数据集的特定任务知识的完美载体。我们的实验表明，在一些困难的序列任务中，多任务学习可以作为<code>P-Tuning v2</code>的有益补充。</li>
<li><strong>回归传统的分类标签范式，而不是映射器</strong>。标签词映射器（Label Word Verbalizer）一直是提示优化的核心组成部分，它将<code>one-hot</code>类标签变成有意义的词，以利用预训练语言模型头。尽管它在<code>few-shot</code>设置中具有潜在的必要性，但在全数据监督设置中，<code>Verbalizer</code>并不是必须的。它阻碍了提示调优在我们需要无实际意义的标签和句子嵌入的场景中的应用。因此，<code>P-Tuning v2</code>回归传统的<code>CLS</code>标签分类范式，采用随机初始化的分类头（Classification Head）应用于<code>tokens</code>之上，以增强通用性，可以适配到序列标注任务。</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>PEFT</tag>
      </tags>
  </entry>
  <entry>
    <title>Parameter Efficient Fine-Tuning(PEFT)系列论文总结(一)</title>
    <url>/2023/12/24/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本篇主要介绍早期的<code>PEFT</code>方法，包括<code>Adapter</code>适配器方法、<code>PET</code>、<code>Prefix Tuning</code>以及<code>Prompt Tuning</code>。</p>
<span id="more"></span>

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>当前主流微调方法分为：<code>Fine-tune</code>和<code>PEFT</code>。</p>
<p><code>Fine-tune</code>，也叫全参微调。在<code>LLM</code>出现之前，<code>Bert</code>系列微调模型一直用的这种方法，即模型的全部参数权重参与更新以适配领域数据(有硬件条件的话自然是最好的选择)。</p>
<p><code>PEFT</code>, 包括<code>Prefix Tuning</code>、<code>P-Tuning V1/V2</code>、<code>LoRA</code>、<code>AdaLoRA</code>、<code>QLoRA</code>等方法，即部分模型参数参与微调。这种方式训练快，显存占用少，但是效果可能跟<code>FT（fine-tune）</code>比会稍有损失。</p>
<h2 id="二、Adapter适配器方法"><a href="#二、Adapter适配器方法" class="headerlink" title="二、Adapter适配器方法"></a>二、Adapter适配器方法</h2><p>谷歌的研究人员于2019年在论文<code>《Parameter-Efficient Transfer Learning for NLP》</code>提出针对 <code>BERT </code>的 <code>PEFT</code> 微调方式，拉开了 <code>PEFT </code>研究的序幕。他们指出：</p>
<ul>
<li>在面对特定的下游任务时，如果进行 <code>Full-fintuning</code>（即预训练模型中的所有参数都进行微调），过于低效</li>
<li>而如果采用固定预训练模型的某些层，只微调接近下游任务的那几层参数，又难以达到较好的效果</li>
</ul>
<p>于是他们设计了如下图所示的 <code>Adapter</code> 结构，作为全模型微调的一种替代方案:</p>
<img src="/2023/12/24/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/image-20231226185027290.png" alt="image-20231226185027290" style="zoom:67%;">

<p>在预训练模型每一层(或某些层)中添加<code>Adapter</code>模块(如上图左侧结构所示)，微调时冻结预训练模型主体，由<code>Adapter</code>模块学习特定下游任务的知识。每个<code>Adapter</code>模块由两个前馈子层组成，第一个前馈子层将<code>Transformer</code>块的输出作为输入，将原始输入维度<code>d</code>投影到<code>m</code>，通过控制<code>m</code>的大小来限制<code>Adapte</code>r模块的参数量，通常情况下<code>m&lt;&lt;d</code>。在输出阶段，通过第二个前馈子层还原输入维度，将<code>m</code>重新投影到<code>d</code>，作为<code>Adapter</code>模块的输出(如上图右侧结构)。</p>
<p>可以看到每一个<code>Adapter Layer</code>需要训练的参数，包括偏置的话是: <code>2md + m + d</code></p>
<p>通过添加<code>Adapter</code>模块来产生一个易于扩展的下游模型，每当出现新的下游任务，通过添加<code>Adapter</code>模块来避免全模型微调与灾难性遗忘的问题。<code>Adapter</code>方法不需要微调预训练模型的全部参数，通过引入少量针对特定任务的参数，来存储有关该任务的知识，降低对模型微调的算力要求。</p>
<img src="/2023/12/24/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/image-20231226192458146.png" alt="image-20231226192458146" style="zoom:67%;">

<img src="/2023/12/24/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/image-20240101220641347.png" alt="image-20240101220641347" style="zoom:80%;">

<p>从实验结果来看，该方法能够在只额外对增加的<code>3.6%</code>参数规模（相比原来预训练模型的参数量）的情况下取得和<code>Full-finetuning</code>接近的效果（<code>GLUE</code>指标在<code>0.4%</code>以内）</p>
<h2 id="三、Pattern-Exploiting-Training-PET"><a href="#三、Pattern-Exploiting-Training-PET" class="headerlink" title="三、Pattern-Exploiting Training(PET)"></a>三、Pattern-Exploiting Training(PET)</h2><p>想要更好的理解下文将讲的<code>Prefix Tuning/P-Tuning</code>，便不得不提<code>Pattern-Exploiting Training(PET)</code>，所谓<code>PET</code>，主要的思想是借助由自然语言构成的模版(英文常称<code>Pattern</code>或<code>Prompt</code>)，将下游任务也转化为一个完形填空任务，这样就可以用<code>BERT</code>的<code>MLM</code>模型来进行预测了。</p>
<p>比如下图中通过条件前缀来实现情感分类和主题分类的例子:</p>
<img src="/2023/12/24/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/957788384.png" alt="img" style="zoom:80%;">

<p>当然，这种方案也不是只有<code>MLM</code>模型可行，用<code>GPT</code>这样的单向语言模型其实也很简单：</p>
<img src="/2023/12/24/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/2581387139.png" alt="img" style="zoom:80%;">

<p>不过由于语言模型是从左往右解码的，因此预测部分只能放在句末了(但还可以往补充前缀说明，只不过预测部分放在最后)</p>
<p>这种人为构造提示模板，就是在输入上加<code>Prompt</code>文本，再对输出进行映射。但这种方式怎么想都不是很优雅，无法避免人工的介入。即使有方法可以批量挖掘，但也有些复杂（有这个功夫能标不少高质量语料），而且模型毕竟是黑盒，对离散文本输入的鲁棒性很差。</p>
<h2 id="四、Prefix-Tuning"><a href="#四、Prefix-Tuning" class="headerlink" title="四、Prefix Tuning"></a>四、Prefix Tuning</h2><p>在<code>Prefix Tuning</code>之前的工作主要是人工设计离散的<code>template</code>或者自动化搜索离散template，问题在于最终的性能对人工设计的<code>template</code>的特别敏感：加一个词或者少一个词，或者变动位置，都会造成很大的变化，所以这种离散化的<code>token</code>的搜索出来的结果可能并不是最优的，下图给出的是一个例子：<br><img src="/2023/12/24/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/image-20240106145327787.png" alt="image-20240106145327787"></p>
<p><strong>论文摘要：</strong>微调是利用大型预训练语言模型执行下游任务的实际方法。然而，它修改了所有语言模型参数，因此需要为每个任务存储一个完整的副本。在本文中，我们提出了一种名为“前缀调优”的轻量级微调替代方法，用于自然语言生成任务。这种方法保持语言模型参数不变，但优化了一个小型的连续任务特定向量(称为前缀)。前缀调优从提示方法中获得灵感，允许后续标记关注这个前缀，就像它们是”虚拟标记”。我们将前缀调优应用于<code>GPT-2</code>进行表格到文本的生成，以及使用BART进行摘要生成。我们发现，通过仅学习<code>0.1%</code>的参数，前缀调优在完整数据集中获得了与微调相当的性能，在低数据设置中表现更好，并且能够更好地推广到训练中未见的主题。</p>
<p><code>Prefix Tuning</code>是<code>PEFT</code>方法之一，<code>Prefix Tuning</code>之前的工作主要是人工设计模板或者自动化搜索模板，也是<code>prompt</code>范式的第一阶段，就是在输入上加上<code>prompt</code>文本，再对输出进行映射。这种离散模板对模型的鲁棒性很差。所以后续的研究都将离散的方式转成连续。<code>Prefix Tuning</code>在模型输入前添加一个连续的且任务特定的向量序列称之为<code>prefix</code>，固定<code>PLM(预训练模型)</code>的所有参数，只更新优化特定任务的<code>prefix</code>。</p>
<img src="/2023/12/24/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/image-20231226200610499.png" alt="image-20231226200610499" style="zoom:67%;">

<h3 id="4-1-适配不同任务的prefix构造形式"><a href="#4-1-适配不同任务的prefix构造形式" class="headerlink" title="4.1 适配不同任务的prefix构造形式"></a>4.1 适配不同任务的prefix构造形式</h3><p>针对不同的模型结构，需要构造不同的 <code>Prefix</code>。</p>
<ul>
<li>针对自回归架构模型：在句子前面添加前缀，得到 <code>z = [PREFIX; x; y]</code>，合适的上文能够在固定 <code>LM</code> 的情况下去引导生成下文（比如：<code>GPT3</code>的上下文学习）。</li>
<li>针对编码器-解码器架构模型：<code>Encoder</code>和<code>Decoder</code>都增加了前缀，得到 <code>z = [PREFIX; x; PREFIX&#39;; y]</code>。</li>
<li><code>Encoder</code>端增加前缀是为了引导输入部分的编码，<code>Decoder</code> 端增加前缀是为了引导后续<code>token</code>的生成。</li>
</ul>
<img src="/2023/12/24/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/image-20231228111353270.png" alt="image-20231228111353270" style="zoom:67%;">

<h3 id="4-2-对virtual-token的编码方式"><a href="#4-2-对virtual-token的编码方式" class="headerlink" title="4.2 对virtual token的编码方式"></a>4.2 对virtual token的编码方式</h3><p>​		同时，为了防止直接更新 <code>Prefix</code> 的参数导致训练不稳定和性能下降的情况，在 <code>Prefix</code> 层前面加了 <code>MLP</code> 结构，训练完成后，只保留 <code>Prefix</code> 的参数。</p>
<p>​		除此之外，通过消融实验证实，只调整<code>embedding</code>层的表现力不够，将导致性能显著下降，因此，在每层<code>Transformer</code>的输入部分都加了<code>prompt</code>的参数，改动较大。</p>
<h2 id="四、Prompt-Tuning"><a href="#四、Prompt-Tuning" class="headerlink" title="四、Prompt Tuning"></a>四、Prompt Tuning</h2><p>2021年4月，<code>Google Research</code>通过此篇论文《<a href="https://arxiv.org/pdf/2104.08691">The Power of Scale for Parameter-Efficient Prompt Tuning</a>》提出了<code>Prompt Tuning</code>，论文中指出，该方法可以看作是<code>Prefix Tuning</code>的简化版本。</p>
<ul>
<li><p><code>Prefix Tuning</code>在每层<code>Transformer</code>的输入部分都加了<code>prompt</code>的参数，相比之下，<code>Prompt Tuning</code>使用单个提示表示，该表示前置于嵌入式输入。除了需要更少的参数外，所提出方法允许<code>Transformer</code>更新中间层任务表示。</p>
</li>
<li><p>此外，<code>Prefix tuning</code>也依赖于前缀的重新参数化来稳定学习，这在训练期间增加了大量参数，而<code>Prefix tuning</code>的配置不需要这种重新参数化，并且在<code>SuperGLUE</code>任务和模型尺寸上都是鲁棒的。</p>
</li>
<li><p>它冻结整个预训练模型，只允许每个下游任务在输入文本前添加额外的k个可调<code>tokens</code>(意味着它给每个任务都定义了自己的<code>Prompt</code>，在输入层加入<code>prompt tokens</code>)</p>
</li>
</ul>
<p>具体而言，如下图所示：</p>
<img src="/2023/12/24/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/image-20240107102116261.png" alt="image-20240107102116261" style="zoom:80%;">

<ul>
<li><p><code>Model Tuning</code>需要为每个下游任务生成整个预训练模型的任务特定副本，并且推理必须分批执行</p>
</li>
<li><p><code>Prompt Tuning</code>只需要为每个任务存储一个小的特定于任务的提示，并使用原始的预训练模型支持混合任务推理</p>
</li>
</ul>
<p>且通过实验发现，随着预训练模型参数量的增加，<code>Prompt Tuning</code>的方法会逼近全参数微调的结果</p>
<img src="/2023/12/24/Parameter%20Efficient%20Fine-Tuning(PEFT)%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/image-20240107103047631.png" alt="image-20240107103047631" style="zoom:80%;">
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>PEFT</tag>
      </tags>
  </entry>
  <entry>
    <title>RAG综述小结</title>
    <url>/2024/01/09/RAG%E7%BB%BC%E8%BF%B0%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>本章是同济大学对于当前RAG技术的综述，对照翻译进行了小结，当作了解</p>
<span id="more"></span>

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>尽管大模型的能力令人印象深刻，但它们并非无懈可击。这些模型可能会产生误导性的 “幻觉”，依赖的信息可能过时，处理特定知识时效率不高，缺乏专业领域的深度洞察，同时在推理能力上也有所欠缺。</p>
<p>在现实世界的应用中，数据需要不断更新以反映最新的发展，生成的内容必须是透明可追溯的，以便控制成本并保护数据隐私。因此，简单依赖于这些 “黑盒” 模型是不够的，我们需要更精细的解决方案来满足这些复杂的需求。</p>
<p>因此，检索增强生成技术（Retrieval-Augmented Generation，RAG）应时而生，成为 AI 时代的一大趋势。</p>
<p><strong>一句话概括RAG:</strong> RAG 通过在语言模型生成答案之前，先从广泛的文档数据库中检索相关信息，然后利用这些信息来引导生成过程。</p>
<p>这极大地提升了内容的准确性和相关性。RAG 有效地缓解了幻觉问题，提高了知识更新的速度，并增强了内容生成的可追溯性，使得大型语言模型在实际应用中变得更加实用和可信。</p>
<p><strong>检索增强与微调</strong></p>
<p>可以把 RAG 想象成给模型提供一本教科书，让它根据特定的问题去查找信息。这种方法适用于模型需要解答具体问题或执行特定信息检索任务的情况。但 RAG 并不适合于教会模型理解广泛的领域或学习新的语言、格式或风格。</p>
<p>而微调更像是让学生通过广泛学习来吸收知识。</p>
<p>当模型需要模仿特定的结构、风格或格式时，微调就显得非常有用。它可以提高未经微调的模型的表现，使交互更加高效。</p>
<p>微调特别适用于强化模型已有的知识、调整或定制模型的输出，以及给模型下达复杂的指令。然而，微调并不适合于向模型中添加新的知识，或者在需要快速迭代新场景的情况下使用。</p>
<p><img src="/2024/01/09/RAG%E7%BB%BC%E8%BF%B0%E5%B0%8F%E7%BB%93/image-20240223194102311.png" alt="image-20240223194102311"></p>
<img src="/2024/01/09/RAG%E7%BB%BC%E8%BF%B0%E5%B0%8F%E7%BB%93/image-20240123104215622.png" alt="image-20240123104215622" style="zoom: 50%;">

<p>RAG 的概念首次于 2020 年被提出，随后进入高速发展，如图所示的是RAG 技术发展的科技树。</p>
<p>RAG 的相关研究进展可以明确地划分为数个关键阶段。在早期的预训练阶段，研究的焦点集中在如何通过预训练模型注入额外的知识，以此增强语言模型的能力。随着 ChatGPT的面世，对于运用大型模型进行深层次上下文学习的兴趣激增，这推动了 RAG 技术在研究领域的快速发展。随着 LLMs 的潜力被进一步开发，旨在提升模型的可控性并满足不断演变的需求，RAG 的研究逐渐聚焦于增强推理能力，并且也探索了在微调过程中的各种改进方法。特别是随着 GPT-4 的发布，RAG 技术经历了一次深刻的变革。研究重点开始转移至一种新的融合 RAG 和微调策略的方法，并且持续关注对预训练方法的优化。</p>
<p>在 RAG 的技术发展过程中，从技术范式角度，将其总结成如下几个阶段：</p>
<p>1、Naive RAG</p>
<p>2、Advanced RAG</p>
<p>3、Modular RAG</p>
<h2 id="二、Naive-RAG"><a href="#二、Naive-RAG" class="headerlink" title="二、Naive RAG"></a>二、Naive RAG</h2><p><img src="/2024/01/09/RAG%E7%BB%BC%E8%BF%B0%E5%B0%8F%E7%BB%93/image-20240123110958566.png" alt="image-20240123110958566"></p>
<p>上图所示的是经典的RAG流程，称为Naive RAG，朴素版</p>
<p>主要包括如下三个步骤：</p>
<p>1、索引——将文档库分割成较短的Chunk，并通过某个embedding模型构建向量索引</p>
<p>2、检索——将问题通过同样的embedding模型和文本Chunk作相似度匹配检索相关的文档片段</p>
<p>3、生成——以检索到的上下文用某种Prompt构造方式喂入大模型，让其生成问题的回答</p>
<p>朴素 RAG 主要在三个方面面临挑战：检索质量、回应生成质量和增强过程。</p>
<p>1、<strong>检索质量：</strong>最主要的问题是低精度，即检索集中的文档块并不都与查询内容相关，这可能导致信息错误或不连贯。其次是低召回率问题，即未能检索到所有相关的文档块，使得大语言模型无法获取足够的背景信息来合成答案。此外，过时信息也是一个挑战，因为数据冗余或过时可能导致检索结果不准确。</p>
<p>2、<strong>回应生成质量：</strong>最突出的问题是制造错误信息，即模型在缺乏足够上下文的情况下虚构答案。另一个问题是回答不相关，即模型生成的答案未能针对查询问题。进一步来说，生成有害或偏见性回应也是一个问题。</p>
<p>3、<strong>增强过程：</strong> 最终，增强过程面临几个重要挑战。特别重要的是，如何将检索到的文段的上下文有效融入当前的生成任务。如果处理不得当，生成的内容可能显得杂乱无章。当多个检索到的文段包含相似信息时，冗余和重复成为问题，这可能导致生成内容的重复。此外，如何判断多个检索到的文段对生成任务的重要性或相关性非常有挑战性，增强过程需要恰当地评估每个文段的价值。检索到的内容可能具有不同的写作风格或语调，增强过程需调和这些差异，以确保最终输出的一致性。最后，生成模型可能会过度依赖于增强信息，导致生成的内容仅是重复检索到的信息，而缺乏新的价值或综合信息。</p>
<h2 id="三、Advanced-RAG"><a href="#三、Advanced-RAG" class="headerlink" title="三、Advanced RAG"></a>三、Advanced RAG</h2><p><img src="/2024/01/09/RAG%E7%BB%BC%E8%BF%B0%E5%B0%8F%E7%BB%93/image-20240123111840061.png" alt="image-20240123111840061"></p>
<p>Naive RAG 在检索质量、响应生成质量以及增强过程中会有很多问题，最突出的就是召回文档质量不佳的问题，继而严重影响了后续的生成质量</p>
<p>因此Advanced RAG 范式随后被提出，并在数据索引、检索前和检索后都进行了额外处理。通过更精细的数据清洗、设计文档结构和添加元数据等方法提升文本的一致性、准确性和检索效率。在检索前阶段则可以使用<strong>问题的重写、路由和扩充</strong>等方式对齐问题和文档块之间的语义差异。在检索后阶段则可以通过将检索出来的文档库进行重排序避免 “Lost in the Middle ” 现象的发生。或是通过上下文筛选与压缩的方式缩短窗口长度</p>
<p>上图中的绿色元素是接下来讨论的核心检索增强生成（RAG）技术，蓝色的则是文本</p>
<p>下面逐一来介绍核心RAG技术，非常的多：</p>
<h3 id="3-1-Query-transformations"><a href="#3-1-Query-transformations" class="headerlink" title="3.1 Query transformations"></a>3.1 Query transformations</h3><p>Query transformations(查询转换)是一组技术，使用LLM作为推理引擎来修改用户输入以提高检索质量。</p>
<p>有几种不同的方法可以做到这一点</p>
<img src="/2024/01/09/RAG%E7%BB%BC%E8%BF%B0%E5%B0%8F%E7%BB%93/image-20240123170205815.png" alt="image-20240123170205815" style="zoom: 67%;">

<p>如果某个查询是复杂的，LLM可以将其分解为几个简单的子查询</p>
<p>例如你问：<code>“在GitHub上，Langchain和LlamaIndex哪个框架的星星更多？&quot;</code></p>
<p>可能对于这个问题，语料库中没有直接的文本能给出问题的直接答案。但是如果将这个问题分解为两个子查询，那或许是能找到相关的信息，例如将上面的问题分解为：<code>“Langchain在GitHub上有多少星星？”</code>和<code>“LlamaIndex在GitHub上有多少星星？” </code></p>
<p>这些查询将并行执行，然后将检索到的上下文合并为一个提示，供LLM合成对初始查询的最终答案。这两个库都实现了这个功能——在<code>Langchain</code>中作为多查询检索器，在<code>LlamaIndex</code>中作为子问题查询引擎。</p>
<p>查询转换的好处在于：</p>
<p>1、逐步提示使用LLM生成更一般的查询，我们检索到的上下文更一般或高层次，有助于支持我们原始查询的答案。并且，原始查询也会执行检索，并且在最终生成答案的步骤中，将转换后的查询检索到的两个上下文一起输入LLM。</p>
<p>2、查询重写使用LLM重新表述初始查询以改善检索。<code>LangChain</code>和<code>LlamaIndex</code>都有实现。</p>
<h3 id="3-2-Query-Routing"><a href="#3-2-Query-Routing" class="headerlink" title="3.2 Query Routing"></a>3.2 Query Routing</h3><p>Query Routing(查询路由)是在给定用户查询的情况下，由LLM驱动的决策步骤，决定下一步要做什么——通常的选择是总结、对某些数据索引执行搜索，或尝试多种不同的路线，然后将它们的输出综合成一个答案。</p>
<h3 id="3-3-Fusion-Retrieval"><a href="#3-3-Fusion-Retrieval" class="headerlink" title="3.3 Fusion Retrieval"></a>3.3 Fusion Retrieval</h3><p>Fusion Retrieval(混合检索)的优势在于它结合了不同检索技术的长处。它智能地融合了关键词搜索、语义搜索和向量搜索等多种技术，适应不同类型的查询需求，确保能够一致地检索到最相关和内容丰富的信息。混合检索作为检索策略的重要补充，能够显著提升 RAG 流程的整体性能。</p>
<p>1、基于关键词的传统搜索——稀疏检索算法，如<code>tf-idf</code>或搜索行业标准<code>BM25</code> </p>
<p>2、现代语义或向量搜索</p>
<p>  最后将上述检索结果合并到一个检索结果中</p>
<h3 id="3-4-Re-rank"><a href="#3-4-Re-rank" class="headerlink" title="3.4 Re-rank"></a>3.4 Re-rank</h3><img src="/2024/01/09/RAG%E7%BB%BC%E8%BF%B0%E5%B0%8F%E7%BB%93/image-20240123202207150.png" alt="image-20240123202207150" style="zoom:80%;">

<p>Re-rank(重新排序)，将最相关的信息置于提示的前后边缘，是一个简单直接的方法。这一思路已在如 <code>LlamaIndex</code>、<code>LangChain</code> 和 <code>HayStack</code> 等框架中得到应用。例如，<code>Diversity Ranker</code>会根据文档的多样性进行重新排序，而<code> LostInTheMiddleRanker</code> 则会交替地将最佳文档放在上下文窗口的开始和结束位置。同时，为了应对基于向量的语义相似度模拟搜索的挑战，方法如 <code>cohereAI rerank </code>、<code>bgererank5</code> 或 <code>LongLLMLingua</code>，会重新计算相关文本与查询之间的语义相似度。</p>
<h3 id="3-5-Embedding"><a href="#3-5-Embedding" class="headerlink" title="3.5 Embedding"></a>3.5 Embedding</h3><h4 id="3-5-1-微调嵌入"><a href="#3-5-1-微调嵌入" class="headerlink" title="3.5.1 微调嵌入"></a>3.5.1 微调嵌入</h4><p>微调嵌入模型的调整直接影响到 RAG 的有效性。微调的目的是让检索到的内容与查询之间的相关性更加紧密。微调嵌入的作用可以比作在语音生成前对“听觉”进行调整，优化检索内容对最终输出的影响。通常，微调嵌入的方法可以分为针对特定领域上下文的嵌入调整和检索步骤的优化。特别是在处理不断变化或罕见术语的专业领域，这些定制化的嵌入方法能够显著提高检索的相关性。<code>BGE</code>嵌入模型是一个经过微调的高性能嵌入模型，例如由 <code>BAAI 3</code> 开发的 <code>BGE-large-EN</code>。为了对 BGE 模型进行微调，首先使用诸如 <code>gpt-3.5-turbo</code> 这样的大语言模型（LLM）根据文档块制定问题，其中问题和答案（文档块）构成了微调过程中的训练对。</p>
<h4 id="3-5-2-动态嵌入"><a href="#3-5-2-动态嵌入" class="headerlink" title="3.5.2 动态嵌入"></a>3.5.2 动态嵌入</h4><p>不同于静态嵌入，动态嵌入根据单词出现的上下文进行调整，为每个单词提供不同的向量表示。例如，在 <code>Transformer</code> 模型（如 <code>BERT</code>）中，同一单词根据周围词汇的不同，其嵌入也会有所变化。研究发现，在 OpenAI的 <code>text-embeddingada-002</code> 模型中，文本长度小于 5 个 <code>token</code> 时，常出现意外高的余弦相似度。理想的嵌入应该包含足够的上下文，以保证良好的结果。OpenAI 的 <code>embeddings-ada-02</code> 是基于大语言模型（如 GPT）原理开发的，比传统静态嵌入模型更复杂，能够捕捉一定程度的上下文。尽管它在上下文理解方面表现出色，但可能不如最新的大语言模型（如 GPT-4）那样对上下文敏感。</p>
<h3 id="3-6-HyDE"><a href="#3-6-HyDE" class="headerlink" title="3.6 HyDE"></a>3.6 HyDE</h3><p>这种方法基于一个假设：相较于直接查询，通过大语言模型 (LLM) 生成的答案在嵌入空间中可能更为接近。HyDE 首先响应查询生成一个假设性文档（答案），然后将其嵌入，并利用此嵌入去检索与假设文档类似的真实文档。这种方法强调答案之间的嵌入相似性，而非单纯依赖于查询的嵌入相似性。但在某些情况下，特别是当语言模型对话题不够熟悉时，它可能导致错误实例的增加。</p>
<h2 id="四、Modular-RAG"><a href="#四、Modular-RAG" class="headerlink" title="四、Modular RAG"></a>四、Modular RAG</h2><p><strong>搜索模块：</strong> 与简单&#x2F;高级 RAG 的查询和语料间的常规相似性检索不同，这个特定场景下的搜索模块融合了直接在（附加的）语料库中进行搜索的方法。这些方法包括利用大语言模型（LLM）生成的代码、SQL、Cypher 等查询语言，或是其他定制工具。其搜索数据源多样，涵盖搜索引擎、文本数据、表格数据或知识图等。</p>
<p><strong>额外生成模块：</strong> 面对检索内容中的冗余和噪声问题，这个模块通过大语言模型生成必要的上下文，而非直接从数据源进行检索。通过这种方式，由大语言模型生成的内容更可能包含与检索任务相关的信息。</p>
<p>非常的多……</p>
<p>……</p>
<h2 id="五、检索器"><a href="#五、检索器" class="headerlink" title="五、检索器"></a>五、检索器</h2><p>在 RAG（检索增强生成）技术中，“R”代表检索，其作用是从大量知识库中检索出最相关的前 k 个文档</p>
<h3 id="5-1-如何获得准确的语义表示？"><a href="#5-1-如何获得准确的语义表示？" class="headerlink" title="5.1 如何获得准确的语义表示？"></a>5.1 如何获得准确的语义表示？</h3><p><strong>块优化</strong></p>
<p>处理外部文档的第一步是分块，以获得更细致的特征。接着，这些文档块被嵌入（Embedded）。</p>
<p>嵌入太大或太小的文本块可能无法取得最佳效果。因此，找到适合语料库文档的最佳块大小至关重要，以确保搜索结果的准确性和相关性。</p>
<p>选择分块策略时，需要考虑的要素包括：被索引内容的特点、使用的嵌入模型及其最适块大小、用户查询的预期长度和复杂度、以及检索结果在特定应用中的使用方式。例如，对于不同长度的内容，应选用不同的分块模型。不同的嵌入模型，如 Sentence-Transformer 和 text-embedding-ada-002，在处理不同大小的文本块时效果各异；例如，Sentence-Transformer 更适合单句处理，而 text-embedding-ada-002 更适合处理包含 256 或 512 Token 的文本块。用户问题文本的长度和复杂性，以及应用程序的特定需求（如语义搜索或问答），也会影响分块策略的选择。这可能与选用的大语言模型的 Token 限制直接相关，因此可能需要调整块大小。实际上，准确的查询结果是通过灵活应用多种分块策略来实现的，并没有最佳策略，只有最适合的策略。</p>
<p>Small2big 技术在搜索过程中使用小文本块，并为语言模型提供更大的相关文本块进行处理。摘要嵌入（Abstract embedding）技术对文档摘要执行 Top K 检索，以提供完整的文档上下文。元数据过滤（Metadata Filtering）技术通过文档的元数据进行过滤。图索引（Graph Indexing）技术把实体和关系转化为节点和连接，这在处理多跳问题时显著提升了相关性。这些方法的结合显著提升了 RAG 的检索效果和性能。</p>
<p><strong>微调嵌入模型</strong></p>
<p>在确定了 Chunk 的适当大小之后，我们需要通过一个嵌入模型（Embedding model）将 Chunk 和查询嵌入到语义空间中。因此，嵌入模型是否能有效代表整个语料库变得极其重要。如今，一些出色的嵌入模型已经问世，例如 UAE[AngIE, 2023]、Voyage[VoyageAI, 2023]、BGE[BAAI, 2023] 等，它们在大规模语料库上预训练过。但在特定领域中应用时，这些模型可能无法准确地反映领域特定的语料信息。此外，为了确保模型能够理解用户查询与内容的相关性，对嵌入模型进行任务特定的微调至关重要，否则未经微调的模型可能无法满足特定任务的需求。因此，对嵌入模型进行微调对于其下游应用是必不可少的。</p>
<p><strong>领域知识微调</strong></p>
<p>嵌入模型微调的两个基本范式包括领域知识微调。为了让嵌入模型准确理解领域特定信息，我们需要构建专门的领域数据集来对嵌入模型进行微调。</p>
<p>然而，嵌入模型的微调与常规语言模型的微调不同，主要区别在于所使用的数据集。当前微调嵌入模型的主流方法使用的数据集包括查询（Queries）、语料库（Corpus）和相关文档（Relevant Docs）。嵌入模型基于查询在语料库中检索相关文档，然后根据查询的相关文档是否命中作为衡量模型的标准。</p>
<p>在构建数据集、微调模型和评估过程中，每个部分都可能遇到各种挑战。LlamaIndex [Liu, 2023] 专门为嵌入模型的微调过程引入了一系列关键类别和功能，大大简化了这一过程。通过准备领域知识的语料库并利用其提供的方法，我们可以轻松获得适合特定领域需求的专业嵌入模型。</p>
<h3 id="5-2-如何协调查询和文档的语义空间"><a href="#5-2-如何协调查询和文档的语义空间" class="headerlink" title="5.2 如何协调查询和文档的语义空间"></a>5.2 如何协调查询和文档的语义空间</h3><p><strong>查询重写</strong></p>
<p>这种做法使用大模型本身先对查询进行回复，生成一个指导性的伪文档。然后将原始查询与这个伪文档结合，形成一个新的查询。<br>HyDE则是根据查询生成一个假设性文档（答案），然后将其嵌入，并利用此嵌入去检索与假设文档类似的真实文档。</p>
<p><strong>嵌入变换</strong></p>
<p>不太懂</p>
<h2 id="六、生成器"><a href="#六、生成器" class="headerlink" title="六、生成器"></a>六、生成器</h2><p>在 RAG 系统中，生成是核心部分之一，它的职责是将检索到的信息转化为自然流畅的文本。</p>
<h3 id="5-1-如何通过后检索处理提升检索结果？"><a href="#5-1-如何通过后检索处理提升检索结果？" class="headerlink" title="5.1 如何通过后检索处理提升检索结果？"></a>5.1 如何通过后检索处理提升检索结果？</h3><p>后检索处理指的是，在通过检索器从大型文档数据库中检索到相关信息后，对这些信息进行进一步的处理、过滤或优化。其主要目的是提高检索结果的质量，更好地满足用户需求或为后续任务做准备。可以将其理解为对检索阶段获得的文档进行二次处理。后检索处理通常包括信息压缩和结果的重新排序。</p>
<h3 id="5-2-如何优化生成器应对输入数据？"><a href="#5-2-如何优化生成器应对输入数据？" class="headerlink" title="5.2 如何优化生成器应对输入数据？"></a>5.2 如何优化生成器应对输入数据？</h3><p>在 RAG 模型中，优化生成器是至关重要的。生成器负责将检索到的信息转化为相关文本，形成模型的最终输出。其优化目的在于确保生成文本既流畅又能有效利用检索文档，更好地回应用户的查询。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>RAG综述</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformers 理解</title>
    <url>/2023/06/27/Transformers/</url>
    <content><![CDATA[<p>本章是Transformers精讲，并配备哈佛版的基于Pytorch的实现代码</p>
<span id="more"></span>

<h2 id="一、宏观角度"><a href="#一、宏观角度" class="headerlink" title="一、宏观角度"></a>一、宏观角度</h2><p>1、首先将该模型视为一个黑匣子。 在机器翻译应用程序中，它将采用一种语言的句子，并以另一种语言输出其翻译。</p>
<p><img src="/2023/06/27/Transformers/image-20240113204413171.png" alt="image-20240113204413171"></p>
<p>2、继续瓦解，可以看到一个编码组件、一个解码组件以及它们之间的连接。</p>
<p><img src="/2023/06/27/Transformers/image-20240113204543371.png" alt="image-20240113204543371"></p>
<p>3、编码组件是一堆<code>Encoder</code>（论文将其中六个编码器堆叠在一起 - 6 没有什么神奇之处，绝对可以尝试其他排列）。 解码组件是相同数量的<code>Decoder</code>的堆栈。</p>
<p><img src="/2023/06/27/Transformers/image-20240113204719720.png" alt="image-20240113204719720"></p>
<p>4、这些编码器在结构上都是相同的（但它们不共享权重）。 每一层又分为两个子层：</p>
<p><img src="/2023/06/27/Transformers/image-20240113204801613.png" alt="image-20240113204801613"><code>Encoder</code>的输入首先流经<code>Self-Attention</code>，该层帮助编码器在对特定单词进行编码时查看输入句子中的其他单词。 <code>Self-Attention</code>将在后续小节详细介绍。</p>
<p><code>Self-Attention</code>的输出被馈送到前馈神经网络。 完全相同的前馈网络独立应用于每个位置。</p>
<p>5、<code>Decoder</code>具有这两个层，但它们之间是一个注意力层，帮助解码器关注输入句子的相关部分（类似于 <code>seq2seq</code> 模型中注意力的作用）。</p>
<p><img src="/2023/06/27/Transformers/image-20240113205106009.png" alt="image-20240113205106009"></p>
<p>6、有了宏观的感受，再来看一下原论文中的图</p>
<img src="/2023/06/27/Transformers/image-20240113205906204.png" alt="image-20240113205906204" style="zoom:67%;">

<p>拆解完再回过来看是不是更清晰，接下来我将逐一介绍其中的各个模块，并配有<code>Pytorch</code>代码实现</p>
<h2 id="二、Self-Attention"><a href="#二、Self-Attention" class="headerlink" title="二、Self-Attention"></a>二、Self-Attention</h2><h3 id="2-1-理论部分"><a href="#2-1-理论部分" class="headerlink" title="2.1 理论部分"></a>2.1 理论部分</h3><p>其实按照模型流程应该先介绍输入部分</p>
<p>输入部分包括：<strong>词向量嵌入 +  位置向量嵌入</strong>（对应维度直接相加）</p>
<p>但是，先讲完<code>Self-Attention</code>，你就会明白为什么光有词向量嵌入还不够，还需要位置向量嵌入</p>
<p><strong>正式开始Self-Attention</strong></p>
<p><img src="/2023/06/27/Transformers/image-20240113211345136.png" alt="image-20240113211345136"></p>
<p>假设我们已经得到了模型的输入，每个单词都嵌入到大小为 512 的向量中。我将用这些简单的框表示这些向量</p>
<p>将单词嵌入到输入序列中后，每个单词都会流经<code>Encoder</code>的两个子层。</p>
<p><img src="/2023/06/27/Transformers/image-20240113211618648.png" alt="image-20240113211618648"></p>
<p>接下来，我将示例切换为较短的句子，去查看编码器的每个子层中发生的情况</p>
<p>正如已经提到的，<code>Encoder</code>接收向量列表作为输入。 它通过将这些向量传递到<code>Self-Attention</code>层，然后传递到前馈神经网络，然后将输出向上发送到下一个<code>Encoder</code>来处理该列表。</p>
<p><img src="/2023/06/27/Transformers/image-20240113211916839.png" alt="image-20240113211916839"></p>
<p><code>Self-Attention</code>即自注意力机制，感动陌生很正常，因为当时正是在这篇论文中提出的</p>
<p>下面我将介绍到底什么叫自注意力机制</p>
<p>假设以下句子是要翻译的输入句子：</p>
<p>”<code>The animal didn&#39;t cross the street because it was too tired</code>”</p>
<p>这句话中的<code>it</code>指的是什么？ 指的是街道还是动物？ 这对人类来说是一个简单的问题，但对算法来说就不那么简单了。</p>
<p>当模型处理<code>it</code>这个词时，自注意力使其能够将<code>it</code>与“动物”联系起来。</p>
<p>当模型处理每个单词（输入序列中的每个位置）时，自注意力允许它查看输入序列中的其他位置以寻找有助于更好地编码该单词的线索。</p>
<p>你肯定还是不明白它是怎么做的，接下来是细节部分</p>
<p>我们首先看看如何使用向量计算自注意力，然后继续看看它是如何实际实现的——使用矩阵。</p>
<p>计算自注意力的第一步是从每个编码器的输入向量（在本例中为每个单词的嵌入）创建三个向量。 因此，对于每个单词，我们创建一个查询向量、一个键向量和一个值向量。 这些向量是通过将<strong>嵌入</strong>乘以我们在训练过程中训练的<strong>三个矩阵</strong>来创建的。</p>
<p><img src="/2023/06/27/Transformers/image-20240113212618490.png" alt="image-20240113212618490"></p>
<p>将 <code>x1 </code>乘以 <code>Wq</code> 权重矩阵会产生 <code>q1</code>，即与该单词关联的“查询”向量。 我们最终为输入句子中的每个单词创建一个“查询”、一个“键”和一个“值”投影。</p>
<p>这里注意一下维度, 在论文中的<code>Embedding</code>维度<code>d_model = 512</code>，给出的<code>Key</code>维度和<code>Value</code>维度均为64</p>
<p>即<code>d_k = d_v = d_model / h = 64</code>，那么对应<code>QKV</code>的矩阵<code>Wq</code>、<code>Wk</code>、<code>Wv</code>大小都应该是（512，64）</p>
<p>这样就能根据输入得到一个查询向量<code>q1</code>，一组键值对<code>&lt;k1,v1&gt;</code></p>
<p>有了<code>QKV</code>, 接下来需要按照<code>Attention</code>的流程计算<code>q1</code>和<code>k1</code>的<code>Score</code></p>
<p> 根据论文中提到的<strong>缩放点积注意力</strong>(Scaled Dot-Product Attention):</p>
<img src="/2023/06/27/Transformers/image-20240113213524039.png" alt="image-20240113213524039" style="zoom: 80%;">

<p>先进行点积, 再进行缩放, 计算完<code>q1</code>与句中所有单词的<code>k1,k2……kn</code>的得分(这里采用点积得到)后, 再对<code>Score</code>除以根号下<code>d_k</code>, 完成缩放, 最后再通过<code>Softmax</code>得到<code>Attention</code>权重, 加权求和结果称为<code>z1</code></p>
<p><img src="/2023/06/27/Transformers/image-20240113213705835.png" alt="image-20240113213705835"></p>
<p>上面的讨论全部都是针对一个单词的, 但是在实际的运算中, 由于<code>Encoder</code>是线性<code>Stack</code>起来的, 所以其实<code>Encoder</code>的训练是可以并行的, 即<strong>多个单词做完Embedding后作为一个矩阵并行计算</strong>, 假设输入矩阵<code>X</code>，通过<code>Wq</code>、<code>Wk</code>、<code>Wv</code>计算后可以得到<code>Q、K、V</code>：</p>
<img src="/2023/06/27/Transformers/image-20240114201121264.png" alt="image-20240114201121264" style="zoom:50%;">

<p>最后，由于我们处理的是矩阵，我们可以将上述步骤压缩为一个公式来计算自注意力层的输出：</p>
<p>​                                                                                        $$ Attention\left( Q,K,V \right) \ &#x3D;\ Soft\max \left( \frac{QK^T}{\sqrt[]{d_k}} \right) V $$ </p>
<img src="/2023/06/27/Transformers/image-20240114201259276.png" alt="image-20240114201259276" style="zoom: 67%;">



<p><strong>这里除以根号下 d_k 的解释</strong>：</p>
<p>当<code>d_k</code>非常大时, 求得的内积可能会非常大, 如果不进行缩放, 不同的内积大小可能差异会非常大, <code>Softmax</code>在指数运算可能将梯度推到特别小, 导致梯度消失</p>
<p>当 <code>d_k</code>较大时，很有可能存在某个 <code>key</code>，其与<code>query</code>计算出来的对齐分数远大于其他的<code>key</code>与该 <code>query</code>算出的对齐分数。这时，<code>softmax</code> 函数对另外的<code>qk</code>偏导数都趋于 0.</p>
<p>这样结果就是，<code>softmax</code>函数梯度过低（趋于零），使得模型误差反向传播经过<code>softmax</code> 函数后无法继续传播到模型前面部分的参数上，造成这些参数无法得到更新，最终影响模型的训练效率</p>
<h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><p><strong>Pytorch代码实现如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">attention</span>(<span class="params">query, key, value, mask=<span class="literal">None</span>, dropout=<span class="literal">None</span></span>):</span><br><span class="line">    d_k = query.size(-<span class="number">1</span>)</span><br><span class="line">    scores = torch.matmul(query, key.transpose(-<span class="number">2</span>, -<span class="number">1</span>))/math.sqrt(d_k)</span><br><span class="line">    <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        scores = scores.masked_fill(mask == <span class="number">0</span>, -<span class="number">1e9</span>)</span><br><span class="line">    p_attn = F.softmax(scores, dim=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> dropout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        p_attn = dropout(p_attn)</span><br><span class="line">    <span class="keyword">return</span> torch.matmul(p_attn, value), p_attn</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>query</code>，<code>key</code>，和 <code>value</code> 的维度是 <code>(batch_size, seq_len, d_model)</code>，其中 <code>seq_len</code> 是输入序列的长度，<code>d_model</code> 是模型的隐藏单元数</p>
</li>
<li><p>在线性映射的步骤中，<code>l(x).view(nbatches, -1, self.h, self.d_k).transpose(1, 2)</code> 使用了多头 (<code>self.h</code>) 和 <code>d_k</code>，它将 <code>query</code>，<code>key</code>，和 <code>value</code> 映射到了 <code>(batch_size, h, seq_len, d_k)</code> 的维度</p>
</li>
<li><p><code>torch.matmul(query, key.transpose(-2, -1))</code> 计算注意力分数，其中 <code>query</code> 和 <code>key</code> 经过了 <code>transpose</code> 操作以匹配维度，最终得到的分数维度是 <code>(batch_size, h, seq_len, seq_len)</code>，在最后两个维度的行上做了<code>softmax</code></p>
</li>
<li><p>在 <code>mask</code> 步骤中，如果有掩码，就使用 <code>scores.masked_fill(mask == 0, -1e9)</code> 将不应考虑的位置的分数设置为一个极小的值 <code>-1e9</code></p>
</li>
<li><p>通过 <code>F.softmax(scores, dim=-1)</code> 对分数进行<code>softmax</code> 操作，得到注意力权重 <code>p_attn</code>，其维度为 <code>(batch_size, h, seq_len, seq_len)</code></p>
</li>
<li><p><code>F.softmax(scores, dim=-1)</code>如果是一个二维的张量，<code>dim=0</code>表示在列上做<code>softmax</code>，<code>dim=1</code>表示在行上做<code>softmax</code></p>
</li>
<li><p>最后通过 <code>torch.matmul(p_attn, value)</code> 得到经过注意力权重调节后的值，其维度为 <code>(batch_size, h, seq_len, d_k)</code></p>
<p><code>batch_size</code> 是每个 batch 的大小，<code>seq_len</code> 是序列的长度，<code>h</code> 是头数，<code>d_k</code> 是每个头的隐藏单元数。在多头注意力机制中，通过对头数进行拼接，最后的输出维度为 <code>(batch_size, seq_len, h * d_k)</code></p>
<h3 id="2-3-多头注意力机制"><a href="#2-3-多头注意力机制" class="headerlink" title="2.3 多头注意力机制"></a>2.3 多头注意力机制</h3><p>多头的思路和<code>CNN</code>中的多个卷积核起到的作用明显是一致的. 所谓”多头”, 放在卷积神经网络里就是卷积层多个卷积核的特征提取过程, 在这里就是进行多次注意力的提取, 就像多个卷积核一样, 多次<strong>不同的初始化矩阵</strong>经过训练可能会有多种<strong>不同的特征,</strong> 每个头用于将输入嵌入投影到不同的表示子空间中，更有利于<strong>不同角度</strong>的特征抽取和信息提取。</p>
<p><img src="/2023/06/27/Transformers/image-20240116133617842.png" alt="image-20240116133617842"></p>
<p>通过多头注意力，为每个头维护单独的 <code>Q/K/V</code> 权重矩阵，从而产生不同的 <code>Q/K/V</code> 矩阵。 正如我们之前所做的那样，我们将 <code>X</code> 乘以 <code>WQ/WK/WV</code> 矩阵以生成 <code>Q/K/V</code> 矩阵。</p>
<p><img src="/2023/06/27/Transformers/image-20240116133811713.png" alt="image-20240116133811713"></p>
<p>如果进行与上面概述相同的自注意力计算，只是使用不同的权重矩阵进行八次不同的计算，我们最终会得到八个不同的 <code>Z </code>矩阵</p>
<p>但是接下来的前馈层不需要八个矩阵——它需要一个矩阵（每个单词一个向量）</p>
<p> 所以我们需要一种方法将这八个压缩成一个矩阵</p>
<p>该怎么做呢？ 将矩阵连接起来，然后将它们乘以一个附加的权重矩阵 <code>Wo</code></p>
<p><img src="/2023/06/27/Transformers/image-20240116134104328.png" alt="image-20240116134104328">这几乎就是多头自注意力的全部内容。 这是相当多的矩阵。 </p>
<p>用下图进行汇总</p>
<p><img src="/2023/06/27/Transformers/image-20240116134218698.png" alt="image-20240116134218698"></p>
<p><strong>Pytorch代码实现如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadedAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, h, d_model, dropout=<span class="number">0.1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiHeadedAttention, self).__init__()</span><br><span class="line">        <span class="comment"># 判断d - model % h是否有余数，如果有就报错</span></span><br><span class="line">        <span class="keyword">assert</span> d_model % h == <span class="number">0</span></span><br><span class="line">        <span class="comment"># d-model一般为512（序列符号的embedding长度），h是头数一般为8</span></span><br><span class="line">        self.h = h</span><br><span class="line">        <span class="comment"># 两者相除得到d_k的长度，即query、key矩阵中的列数</span></span><br><span class="line">        self.d_k = d_model // h</span><br><span class="line">        <span class="comment"># 这里定义的4个线性层, 相当于Wq、Wk、Wv、Wo四个投影矩阵</span></span><br><span class="line">        self.linears = clones(nn.Linear(d_model, d_model), <span class="number">4</span>)</span><br><span class="line">        self.attn = <span class="literal">None</span></span><br><span class="line">        self.dropout = nn.Dropout(p=dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, query, key, value, mask=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Same mask applied to all h heads.</span></span><br><span class="line">            mask = mask.unsqueeze(<span class="number">1</span>)</span><br><span class="line">        nbatches = query.size(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1) Do all the linear projections in batch from d_model =&gt; h x d_k</span></span><br><span class="line">        <span class="comment"># zip中的(query, key, value)相当于原始的输入, 即 词嵌入 + 位置嵌入</span></span><br><span class="line">        <span class="comment"># l(x) 相当于原始嵌入输入过了Wq、Wk、Wv三个映射矩阵得到query, key, value</span></span><br><span class="line">        <span class="comment"># 然后再reshape到 nbatches * head * seq_len * d_k(64)</span></span><br><span class="line">        query, key, value = [l(x).view(nbatches, -<span class="number">1</span>, self.h, self.d_k).transpose(<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">for</span> l, x <span class="keyword">in</span> <span class="built_in">zip</span>(self.linears, (query, key, value))]</span><br><span class="line">        <span class="comment"># 2) Apply attention on all the projected vectors in batch.</span></span><br><span class="line">        x, self.attn = attention(query, key, value, mask=mask, dropout=self.dropout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3) &quot;Concat&quot; using a view and apply a final linear.</span></span><br><span class="line">        x = x.transpose(<span class="number">1</span>, <span class="number">2</span>).contiguous().view(nbatches, -<span class="number">1</span>, self.h * self.d_k)</span><br><span class="line">        <span class="keyword">return</span> self.linears[-<span class="number">1</span>](x)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三、Positional-Encoding"><a href="#三、Positional-Encoding" class="headerlink" title="三、Positional Encoding"></a>三、Positional Encoding</h2><h3 id="3-1-理论部分"><a href="#3-1-理论部分" class="headerlink" title="3.1 理论部分"></a>3.1 理论部分</h3><p>正式因为<code>Transformer</code>采用了纯粹的<code>Attention</code>结构, 不像<code>RNN</code>一样能够通过时间步来反映句子中单词的前后关系, 即不能得知<strong>位置信息</strong>。要知道, 在<code>NLP</code>任务中, <strong>语序</strong>是一个相当重要的属性, 所以必须要通过某种方式让<code>Transformer</code>得知单词的位置, 作者通过<strong>位置编码</strong>在每次进入<code>Encoder</code>和<code>Decoder</code>前将位置信息写入。这样来看, 与其叫位置编码, 不如叫<strong>位置嵌入</strong>。</p>
<p>位置编码可以直接与<code>Embedding</code>的向量相加:</p>
<p><img src="/2023/06/27/Transformers/image-20240114162517162.png" alt="image-20240114162517162"></p>
<p>那这个位置编码是怎么得到的呢？</p>
<p>作者的做法非常有意思, 对不同的单词位置, 不同的<code>Embedding</code>维度, 它的编码都是<strong>唯一</strong>的, 应用正弦和余弦函数也方便<code>Transformer</code>学到位置的特征. 如果将当前单词位置记为<code>pos</code>, 而词向量的某个维度记为<code>i</code>, 那么位置编码的方法为:</p>
<p><img src="/2023/06/27/Transformers/image-20240114162811559.png" alt="image-20240114162811559"></p>
<p>如果我们假设嵌入的维数为<code>4</code>，则实际的位置编码将如下所示：</p>
<p><img src="/2023/06/27/Transformers/image-20240114162837902.png" alt="image-20240114162837902"></p>
<p>根据上述<code>PE</code>的位置编码公式，在这个式子中, 编码周期不受单词位置影响, 仅仅与模型开始设计的<code>d_model</code><br> 和<code>Embedding</code>的不同维度<code>i</code>相关</p>
<p>对于不同的<code>i</code>，根据三角函数的周期公式<code>T = 2Π / w</code>，<code>i</code>的范围是[0，256]</p>
<p>可以得到<code>PE</code>的的周期变化范围是<code>[2Π，10000 * 2Π ]</code></p>
<p>这样看，同一位置上的词语, 对于不同的<code>Embedding</code>维度, 都得到不同的编码, 并且随着<code>i</code>的增大, 位置编码的值的变化就越来越慢. 这种编码对于不同维度的<code>Embedding</code>来说是<strong>唯一</strong>的, 因此模型能够学习到关于<code>Embedding</code>的位置信息。</p>
<p>为什么会选择如上公式呢？作者表示：</p>
<p><img src="/2023/06/27/Transformers/image-20240114195410034.png" alt="image-20240114195410034"></p>
<p>已知三角函数公式如下：</p>
<p><img src="/2023/06/27/Transformers/image-20240114195423850.png" alt="image-20240114195423850"></p>
<p>偏移<code>k</code>后，得到的<code>PE</code>如下：</p>
<p><img src="/2023/06/27/Transformers/image-20240114195522326.png" alt="image-20240114195522326"></p>
<p>作者希望借助上述绝对位置的编码公式，让模型能够学习到相对位置信息</p>
<h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h3><p><strong>Pytorch代码实现如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Embeddings</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model, vocab</span>):</span><br><span class="line">        <span class="built_in">super</span>(Embeddings, self).__init__()</span><br><span class="line">        self.lut = nn.Embedding(vocab, d_model)</span><br><span class="line">        self.d_model = d_model</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.lut(x) * math.sqrt(self.d_model)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PositionalEncoding</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model, dropout, max_len=<span class="number">5000</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(PositionalEncoding, self).__init__()</span><br><span class="line">        self.dropout = nn.Dropout(p=dropout)</span><br><span class="line">        <span class="comment"># pe (5000 * 512)</span></span><br><span class="line">        pe = torch.zeros(max_len, d_model)</span><br><span class="line">        <span class="comment"># position (5000 * 1)</span></span><br><span class="line">        position = torch.arange(<span class="number">0</span>, max_len).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># div_term (256 * 1)</span></span><br><span class="line">        div_term = torch.exp(torch.arange(<span class="number">0</span>, d_model, <span class="number">2</span>) *</span><br><span class="line">                             -(math.log(<span class="number">10000.0</span>) / d_model))</span><br><span class="line">        <span class="comment"># 偶数列</span></span><br><span class="line">        pe[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(position * div_term)</span><br><span class="line">        <span class="comment"># 奇数列</span></span><br><span class="line">        pe[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(position * div_term)</span><br><span class="line">        <span class="comment"># [1, max_len, d_model]</span></span><br><span class="line">        <span class="comment"># pe (1 * 5000 * 512)</span></span><br><span class="line">        pe = pe.unsqueeze(<span class="number">0</span>)</span><br><span class="line">        self.register_buffer(<span class="string">&#x27;pe&#x27;</span>, pe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 输入的最终编码 = word_embedding + positional_embedding</span></span><br><span class="line">        x = x + self.pe[:, :x.size(<span class="number">1</span>)].detach()</span><br><span class="line">        <span class="keyword">return</span> self.dropout(x)</span><br></pre></td></tr></table></figure>



<h2 id="四、Residuals-LN-FFN"><a href="#四、Residuals-LN-FFN" class="headerlink" title="四、Residuals + LN + FFN"></a>四、Residuals + LN + FFN</h2><p>在继续之前，需要提及<code>Encoder</code>架构中的一个细节，即每个编码器中的每个子层（自注意力，<code>ffnn</code>）周围都有一个残差连接，并且后面是层归一化步骤。</p>
<h3 id="4-1-残差连接"><a href="#4-1-残差连接" class="headerlink" title="4.1 残差连接"></a>4.1 残差连接</h3><p><img src="/2023/06/27/Transformers/image-20240116135601496.png" alt="image-20240116135601496"></p>
<p>如果要可视化与自注意力相关的向量和层归一化操作，如下图：</p>
<p><img src="/2023/06/27/Transformers/image-20240116135615871.png" alt="image-20240116135615871"></p>
<p>这也适用于<code>Decoder</code>的子层。 如果我们考虑一个由 <code>2</code> 个堆叠编码器和解码器组成的 <code>Transformer</code>，它看起来会是这样的：</p>
<p><img src="/2023/06/27/Transformers/image-20240116135752823.png" alt="image-20240116135752823"></p>
<h3 id="4-2-层归一化"><a href="#4-2-层归一化" class="headerlink" title="4.2 层归一化"></a>4.2 层归一化</h3><p><code>Layer Norm</code>也是一种类似于<code>Batch Norm</code>的归一化方式, 同样能起到加快收敛的作用, 在<strong>NLP任务</strong>中比较常用</p>
<p><code>Batch Norm</code>中, 记录下一个<code>Batch</code>中每维<code>Feature</code>的均值和方差, 并进行放缩和平移, 即对<strong>不同样本的同一个通道特征</strong>进行归一化</p>
<p>在<code>Layer Norm</code>中, 只是换了一个维度, 我们对<strong>同一个样本的不同通道</strong>进行归一化</p>
<p><img src="/2023/06/27/Transformers/layernorm.png" alt="img"></p>
<p><strong>BN和LN的区别：</strong></p>
<p><strong>主要区别在于 normalization的方向不同！</strong></p>
<p><code>Batch</code>顾名思义是对一个<code>batch</code>进行操作。假设我们有 10行 3列 的数据，即我们的<code>batchsize = 10</code>，每一行数据有三个特征，假设这三个特征是**[身高、体重、年龄]<strong>。那么<code>BN</code>是针对每一列（特征）进行缩放，例如算出</strong>[身高]**的均值与方差，再对身高这一列的10个数据进行缩放。体重和年龄同理。这是一种“列缩放”。</p>
<p>而<code>layer</code>方向相反，它针对的是每一行进行缩放。即只看一笔数据，算出这笔所有特征的均值与方差再缩放。这是一种“行缩放”。</p>
<p>细心的你已经看出来，<code>layer normalization</code>对所有的特征进行缩放，这显得很没道理。我们算出一行这**[身高、体重、年龄]**三个特征的均值方差并对其进行缩放，事实上会因为特征的量纲不同而产生很大的影响。但是<code>BN</code>则没有这个影响，因为<code>BN</code>是对一列进行缩放，一列的量纲单位都是相同的。</p>
<p>那么我们为什么还要使用<code>LN</code>呢？因为<code>NLP</code>领域中，<code>LN</code>更为合适。</p>
<p>如果我们将一批文本组成一个<code>batch</code>，那么<code>BN</code>的操作方向是，对每句话的<strong>第一个</strong>词进行操作。但语言文本的复杂性是很高的，任何一个词都有可能放在初始位置，且词序可能并不影响我们对句子的理解。而<code>BN</code>是<strong>针对每个位置</strong>进行缩放，这<strong>不符合NLP的规律</strong>。</p>
<p>而<code>LN</code>则是针对一句话进行缩放的，且<strong>LN一般用在第三维度</strong>，如<code>[batchsize, seq_len, dims]</code>中的<code>dims</code>，一般为词向量的维度，或者是<code>RNN</code>的输出维度等等，这一维度各个特征的量纲应该相同。因此也不会遇到上面因为特征的量纲不同而导致的缩放问题。</p>
<p><img src="/2023/06/27/Transformers/image-20240116150026767.png" alt="image-20240116150026767"></p>
<p><code>BN</code> 感觉是对样本内部特征的缩放，<code>LN </code>是样本直接之间所有特征的缩放。为啥<code>BN</code>不适合<code>NLP</code> 是因为NLP模型训练里的每次输入的句子都是多个句子，并且长度不一，那么 针对每一句的缩放才更加合理，才能表达每个句子之间代表不同的语义表示，这样让模型更加能捕捉句子之间的上下语义关系。如果要用<code>BN</code>，它首先要面临的长度不一的问题。有时候<code>batch size</code>越小的<code>bn</code>效果更不好</p>
<h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><p><strong>Pytorch代码实现如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LayerNorm</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, features, eps=<span class="number">1e-6</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(LayerNorm, self).__init__()</span><br><span class="line">        <span class="comment"># 层归一化后, 引入这两个可学习参数</span></span><br><span class="line">        <span class="comment"># Layer Normalization 能够更灵活地适应不同的数据分布</span></span><br><span class="line">        <span class="comment"># 练过程中，这两个参数会通过反向传播进行更新，以最优化模型的性能</span></span><br><span class="line">        self.a_2 = nn.Parameter(torch.ones(features))</span><br><span class="line">        self.b_2 = nn.Parameter(torch.zeros(features))</span><br><span class="line">        self.eps = eps</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">       <span class="comment"># mean, std的计算在最后一个维度（emb_dim）上进行的</span></span><br><span class="line">        mean = x.mean(-<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        std = x.std(-<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 对 x - mean 和 (std + self.eps) 的运算仍然是逐元素的，维度与输入张量 x 一致</span></span><br><span class="line">        <span class="comment"># 最终返回的 self.a_2 * (x - mean) / (std + self.eps) + self.b_2 </span></span><br><span class="line">		<span class="comment"># 的形状为(batch_size, seq_len, emb_dim)</span></span><br><span class="line">        <span class="keyword">return</span> self.a_2 * (x - mean) / (std + self.eps) + self.b_2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encoder输出和最后进入FFN之前的Residual+LN</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SublayerConnection</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size, dropout</span>):</span><br><span class="line">        <span class="built_in">super</span>(SublayerConnection, self).__init__()</span><br><span class="line">        self.norm = LayerNorm(size)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, sublayer</span>):</span><br><span class="line">        <span class="keyword">return</span> x + self.dropout(sublayer(self.norm(x)))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PositionwiseFeedForward</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model, d_ff, dropout=<span class="number">0.1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(PositionwiseFeedForward, self).__init__()</span><br><span class="line">        self.w_1 = nn.Linear(d_model, d_ff)</span><br><span class="line">        self.w_2 = nn.Linear(d_ff, d_model)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.w_2(self.dropout(F.relu(self.w_1(x))))</span><br></pre></td></tr></table></figure>



<h2 id="五、Decoder"><a href="#五、Decoder" class="headerlink" title="五、Decoder"></a>五、Decoder</h2><h3 id="5-1-理论部分"><a href="#5-1-理论部分" class="headerlink" title="5.1 理论部分"></a>5.1 理论部分</h3><p>现在我们已经涵盖了<code>Encoder</code>方面的大部分概念，我们基本上也知道了解码器的组件是如何工作的</p>
<p>但让我们看看它们是如何协同工作的</p>
<p><code>Encoder</code>首先处理输入序列。 然后，顶部<code>Decoder</code>的输出被转换为一组注意力向量<code>K</code>和<code> V</code>。这些向量将由每个<code>Decoder</code>在其<code>Encoder-Decoder Attention</code>层中使用，这有助于<code>Decoder</code>关注输入序列中的适当位置：</p>
<p><img src="/2023/06/27/Transformers/transformerdecode1.gif" alt="img"></p>
<p>以下步骤重复该过程，直到到达特殊符号，指示<code>Decoder</code>已完成其输出。 每个步骤的输出在下一个时间步骤中被馈送到底部<code>Decoder</code>，并且<code>Decoder</code>像编码器一样冒泡其解码结果</p>
<p><img src="/2023/06/27/Transformers/transformerdecode2.gif" alt="img"></p>
<p>我们将位置编码嵌入并添加到这些<code>Decoder</code>输入中以指示每个单词的位置，这和处理<code>Encoder</code>的输入时一样</p>
<p><strong>但是我们要知道<code>Decoder</code>中的<code>Attention</code>层的运行方式与<code>Encoder</code>中的运行方式略有不同：</strong></p>
<p>在<code>Decoder</code>中，<code>Attention</code>层只允许关注输出序列中较早的位置。 这是通过在自注意力计算中的 <code>softmax </code>步骤之前屏蔽未来位置（将它们设置为 -inf）来完成的，因为在推理的时候肯定不能看到后面的结果</p>
<p><strong>“Encoder-Decoder Attention”层的工作方式与多头自注意力类似，只不过它从其下面的层创建查询矩阵，并从Encoder最后一层的输出中获取键和值矩阵</strong></p>
<p>若仍然沿用传统<code>Seq2Seq+RNN</code>的思路, Decoder是一个<strong>顺序操作</strong>的结构, 我们代入一个场景来看看。假设我们要执行<strong>机器翻译</strong>任务, 要将<code>我 是 学生</code>翻译为<code>I am Student</code>, 假设所有参数与论文中提到的参数一样, <code>batch size</code>视为1. 根据前面已知的知识, <code>Encoder</code>堆叠后的输入和<code>Embedding</code>的大小是相同的</p>
<p>在这里有三个词语, <code>Embedding</code>且通过<code>Encoder</code>后的编码大小为<code>(3,512)</code>。下面对<code>Decoder</code>进行训练:</p>
<ol>
<li>将起始符<code>&lt;start&gt;</code> 作为初始Decoder输入, 经过Decoder处理和分类得到输出<code>I</code>.</li>
<li>将<code>&lt;start&gt; I</code>作为Decoder输入, 经过Decoder处理和分类得到输出<code>am</code>.</li>
<li>将<code>&lt;start&gt; I am</code>作为Decoder输入, 经过Decoder处理和分类得到输出<code>Student</code>.</li>
<li>将<code>&lt;start&gt; I am student</code>作为Decoder输入, 经过Decoder处理和分类得到结束符<code>&lt;end&gt;</code>.</li>
</ol>
<p>这种预测的方式也称为<strong>自回归</strong></p>
<p>如果想做到<strong>并行</strong>训练, 需要将上面的过程转化为一个这样的矩阵直接作为<code>Decoder</code>的输入</p>
<p>因为在<strong>训练时已知任务标签</strong>, 所以可以产生类似的效果，这种方法被称为<code>Teacher Forcing</code></p>
<p>在论文的图中, <code>Mask</code>操作顺序被放在<code>Q</code>和<code>K</code>计算并缩放后, <code>Softmax</code>计算前。如果继续计算下去, 不做<code>Mask</code>, 与<code>V</code>相乘后得到<code>Attention</code>, 所有时间步信息全部都被泄露给<code>Decoder</code>, 必须用<code>Mask</code>将当前预测的单词信息和之后的单词信息全部遮住。</p>
<p>遮住的方法非常简单, 首先不能使用<code>0</code>进行遮盖, 因为<code>Softmax</code>中用零填充会产生错误, <code>e^0=1</code>. 所以必须要用<code>−∞</code>来填充那些不能被看见的部分. 我们直接生成一个下三角全为<code>0</code>, 上三角全部为<strong>负无穷</strong>的矩阵, 与原数据相加就能完成遮盖的效果</p>
<p><img src="/2023/06/27/Transformers/transformer24.png" alt="img"></p>
<p>做<code>Softmax</code>时, 所有的负无穷全变成了<code>0</code>, 不再干扰计算:</p>
<p><img src="/2023/06/27/Transformers/transformer25.png" alt="img"></p>
<p>其实<code>Mask</code>在对句子的<strong>无效部分<pad>填充</pad></strong>时, 也是用同样方法将所有句子补齐, 无效部分用负无穷填充的</p>
<p><strong>PS:</strong><code>Decoder</code>仍然依赖与先前输出结果作为输入, 所以在正式使用时不能实现并行预测, 但在训练的时结果是已知的, 可以实现并行训练</p>
<h3 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h3><p><strong>Pytorch代码实现如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Decoder</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;Generic N layer decoder with masking.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, layer, N</span>):</span><br><span class="line">        <span class="built_in">super</span>(Decoder, self).__init__()</span><br><span class="line">        self.layers = clones(layer, N)</span><br><span class="line">        self.norm = LayerNorm(layer.size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, memory, src_mask, tgt_mask</span>):</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            x = layer(x, memory, src_mask, tgt_mask)</span><br><span class="line">        <span class="keyword">return</span> self.norm(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecoderLayer</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;Decoder is made of self-attn, src-attn, and feed forward (defined below)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size, self_attn, src_attn, feed_forward, dropout</span>):</span><br><span class="line">        <span class="built_in">super</span>(DecoderLayer, self).__init__()</span><br><span class="line">        self.size = size</span><br><span class="line">        self.self_attn = self_attn</span><br><span class="line">        self.src_attn = src_attn</span><br><span class="line">        self.feed_forward = feed_forward</span><br><span class="line">        self.sublayer = clones(SublayerConnection(size, dropout), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, memory, src_mask, tgt_mask</span>):</span><br><span class="line">        <span class="string">&quot;Follow Figure 1 (right) for connections.&quot;</span></span><br><span class="line">        m = memory</span><br><span class="line">        <span class="comment"># 第一个attention是自注意力，Q，K，V 都是 x</span></span><br><span class="line">        <span class="comment"># 第二个attention的Q是上一层自注意力汇聚输出的x，K和V都是encoder编码的memory</span></span><br><span class="line">        x = self.sublayer[<span class="number">0</span>](x, <span class="keyword">lambda</span> x: self.self_attn(x, x, x, tgt_mask))</span><br><span class="line">        x = self.sublayer[<span class="number">1</span>](x, <span class="keyword">lambda</span> x: self.src_attn(x, m, m, src_mask))</span><br><span class="line">        <span class="keyword">return</span> self.sublayer[<span class="number">2</span>](x, self.feed_forward)</span><br></pre></td></tr></table></figure>

<h2 id="六、The-Final-Linear-and-Softmax-Layer"><a href="#六、The-Final-Linear-and-Softmax-Layer" class="headerlink" title="六、The Final Linear and Softmax Layer"></a>六、The Final Linear and Softmax Layer</h2><p><code>Decoder</code>堆栈输出浮点数向量。 我们如何把它变成一个词？ </p>
<p>这就是最后一个<code>Linear</code>层的工作，后面是 <code>Softmax</code> 层</p>
<p>线性层是一个简单的全连接神经网络，它将<code>Decoder</code>堆栈产生的向量投影到一个更大的向量中，称为<code>logits</code>向量</p>
<p>假设我们的模型知道从训练数据集中学习的 10000 个独特的英语单词（我们模型的“输出词汇”）</p>
<p> 这将使 <code>logits</code> 向量有 10000 个单元格宽——每个单元格对应一个唯一单词的分数。 这就是我们解释线性层模型输出的方式。</p>
<p>然后，<code>Softmax</code> 层将这些分数转换为概率（全部为正，全部加起来为 1.0）。 选择概率最高的单元格，并生成与其关联的单词作为该时间步的输出。</p>
<p><img src="/2023/06/27/Transformers/image-20240117145150356.png" alt="image-20240117145150356"></p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>Transformers</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 二叉搜索树</title>
    <url>/2024/02/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>Leetcode刷题记录——二叉搜索树</p>
<span id="more"></span>
<h2 id="Leetcode700-二叉搜索树中的搜索"><a href="#Leetcode700-二叉搜索树中的搜索" class="headerlink" title="Leetcode700 二叉搜索树中的搜索"></a>Leetcode700 二叉搜索树中的搜索</h2><p>首先明白二叉搜索树的性质：</p>
<p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<p><strong>还是递归三部曲：</strong></p>
<p>1、确定递归函数的参数和返回值</p>
<p>递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点</p>
<p>2、确定终止条件</p>
<p>如果当前<code>root</code>为空，或者找到这个数值了，就返回<code>root</code>节点</p>
<p>3、确定单层递归的逻辑</p>
<p>因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。</p>
<p>如果<code>root.val &gt; val</code>，搜索左子树，如果<code>root.val &lt; val</code>，就搜索右子树，最后如果都没有搜索到，就返回<code>None</code>。</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left, val)</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode98-验证二叉搜索树"><a href="#Leetcode98-验证二叉搜索树" class="headerlink" title="Leetcode98 验证二叉搜索树"></a>Leetcode98 验证二叉搜索树</h2><p>利用二叉搜索树的性质，使用<strong>中序遍历</strong>所有节点，并存入数组<code>res</code></p>
<p>最后遍历<code>res</code>，看是否是递增的数组</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">return</span> self.traversal(root, res)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root, res</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        self.traversal(root.left, res)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        self.traversal(root.right, res)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> res[i] &gt;= res[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode530-二叉搜索树的最小绝对差"><a href="#Leetcode530-二叉搜索树的最小绝对差" class="headerlink" title="Leetcode530 二叉搜索树的最小绝对差"></a>Leetcode530 二叉搜索树的最小绝对差</h2><p>最直观的想法是，跟上一题一样<strong>中序遍历</strong>整棵二叉搜索树，得到一个递增数组。再找出相邻节点的绝对差(因为数组已经是有序的，最小绝对差肯定在相邻节点出现)</p>
<p>为了减少空间消耗，也可以在遍历的时候就计算出相邻节点的绝对差</p>
<p>需要用一个<code>pre</code>节点记录一下<code>cur</code>节点的前一个节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.pre = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> self.pre:</span><br><span class="line">    self.result = <span class="built_in">min</span>(self.result, cur.val-self.pre.val)</span><br><span class="line">self.pre = cur</span><br></pre></td></tr></table></figure>

<p>很巧妙地使得<code>pre</code>记录<code>cur</code>节点的前一个节点</p>
<p>剩下的就还是递归三部曲：</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.result = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.tarversal(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tarversal</span>(<span class="params">self, cur</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.tarversal(cur.left)</span><br><span class="line">        <span class="comment"># 当cur第一次遍历到左叶节点时，pre还是None，不进入逻辑</span></span><br><span class="line">        <span class="keyword">if</span> self.pre:</span><br><span class="line">            self.result = <span class="built_in">min</span>(self.result, cur.val-self.pre.val)</span><br><span class="line">        <span class="comment"># 下一次pre就能指向之前的cur了</span></span><br><span class="line">        self.pre = cur</span><br><span class="line">        self.tarversal(cur.right)</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode501-二叉搜索树中的众数"><a href="#Leetcode501-二叉搜索树中的众数" class="headerlink" title="Leetcode501 二叉搜索树中的众数"></a>Leetcode501 二叉搜索树中的众数</h2><p>首先能想到的是一个比较简单的思路，通用，不只是二叉搜索树，普通树也可以用</p>
<p>用<strong>中序遍历</strong>(什么遍历方式都可以)，将遍历得到的元素以及次数放入一个<code>map</code></p>
<p>最后对<code>map</code>的值进行排序，得到次数最多的几个元素</p>
<p>不用额外空间的话，考虑与上一道题一样的双指针思路</p>
<p>留到下次做的时候再来写</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        self.traversal(root, <span class="built_in">map</span>)</span><br><span class="line">        sorted_map = <span class="built_in">sorted</span>(<span class="built_in">map</span>.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        max_value = sorted_map[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> sorted_map:</span><br><span class="line">            <span class="keyword">if</span> value == max_value:</span><br><span class="line">                res.append(key)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root, <span class="built_in">map</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.traversal(root.left, <span class="built_in">map</span>)</span><br><span class="line">        <span class="built_in">map</span>[root.val] = <span class="built_in">map</span>.get(root.val, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        self.traversal(root.right, <span class="built_in">map</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode236-二叉树的最近公共祖先"><a href="#Leetcode236-二叉树的最近公共祖先" class="headerlink" title="Leetcode236 二叉树的最近公共祖先"></a>Leetcode236 二叉树的最近公共祖先</h2><p>如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先</p>
<p>判断逻辑是：如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先</p>
<p>但是容易忽略一个情况：节点本身p(q)，它拥有一个子孙节点q(p)</p>
<p>其实上述两种情况的代码实现过程都是一样的，也可以说，实现情况一的逻辑，顺便包含了情况二</p>
<p>因为遇到 q 或者 p 就返回，这样也包含了 q 或者 p 本身就是公共祖先的情况</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode235-二叉搜索树的最近公共祖先"><a href="#Leetcode235-二叉搜索树的最近公共祖先" class="headerlink" title="Leetcode235 二叉搜索树的最近公共祖先"></a>Leetcode235 二叉搜索树的最近公共祖先</h2><p>上一题的解题思路完全也可以做</p>
<p>但二叉搜索树由于其特性</p>
<p>1、如果当前根节点的值均大于p和q的val，那么最近公共祖先一定在其左子树</p>
<p>2、如果当前根节点的值均小于p和q的val，那么最近公共祖先一定在其右子树</p>
<p>3、如果当前根节点的值在p和q的val之间，那么该节点就是最近公共祖先</p>
<p>再利用递归去解题即可</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">            <span class="keyword">if</span> left:</span><br><span class="line">                <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">            <span class="keyword">if</span> right:</span><br><span class="line">                <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode701-二叉搜索树中的插入操作"><a href="#Leetcode701-二叉搜索树中的插入操作" class="headerlink" title="Leetcode701 二叉搜索树中的插入操作"></a>Leetcode701 二叉搜索树中的插入操作</h2><p>由于二叉搜索树的特点，插入永远可以在某个叶子节点的位置</p>
<p>只需要一直查找就行，找到了就插入</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val=val)</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            temp = cur</span><br><span class="line">            <span class="keyword">if</span> val &gt; cur.val:</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.left</span><br><span class="line">        <span class="keyword">if</span> val &lt; temp.val:</span><br><span class="line">            temp.left = TreeNode(val=val)</span><br><span class="line">        <span class="keyword">if</span> val &gt; temp.val:</span><br><span class="line">            temp.right = TreeNode(val=val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode538-把二叉搜索树转换为累加树"><a href="#Leetcode538-把二叉搜索树转换为累加树" class="headerlink" title="Leetcode538 把二叉搜索树转换为累加树"></a>Leetcode538 把二叉搜索树转换为累加树</h2><p>还是利用二叉树中的双指针套路，<code>cur</code>和<code>pre</code>的用法，要熟练</p>
<p>根据题目性质，很容易看出是要右中左地去遍历整棵树，再遍历时修改节点的值即可</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        self.pre = <span class="number">0</span></span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, cur</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.traversal(cur.right)</span><br><span class="line">        <span class="keyword">if</span> self.pre != <span class="number">0</span>:</span><br><span class="line">            cur.val = cur.val + self.pre</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.val = cur.val</span><br><span class="line">        self.pre = cur.val</span><br><span class="line">        self.traversal(cur.left)</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode450-删除二叉搜索树中的节点"><a href="#Leetcode450-删除二叉搜索树中的节点" class="headerlink" title="Leetcode450 删除二叉搜索树中的节点"></a>Leetcode450 删除二叉搜索树中的节点</h2><p>对于删除节点，有5种情况</p>
<p>1、找不到该节点</p>
<p>2、删除节点为叶子节点</p>
<p>3、删除节点左子树为空，右子树不为空</p>
<p>4、删除节点右子树为空，左子树不为空</p>
<p>5、删除节点的左右子树均不为空</p>
<p>在处理终止条件时，就要处理删除的逻辑</p>
<p>在接下来的左右子树递归中，去接住递归的返回值(也就是处理完删除节点后的左右子树)</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val == key:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">elif</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = root.right</span><br><span class="line">                <span class="keyword">while</span> cur.left:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                cur.left = root.left</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">return</span> root     </span><br></pre></td></tr></table></figure>

<h2 id="Leetcode669-修剪二叉搜索树"><a href="#Leetcode669-修剪二叉搜索树" class="headerlink" title="Leetcode669 修剪二叉搜索树"></a>Leetcode669 修剪二叉搜索树</h2><p>利用二叉搜索树的性质</p>
<p>很好做题，不要陷入误区，子树需要递归地去判断有没有要删的节点</p>
<p>如果当前节点不符合条件，不能直接删了，可能左右子树中还有符合条件的节点</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">            right = self.trimBST(root.right, low, high)</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; high:</span><br><span class="line">            left = self.trimBST(root.left, low, high)</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        root.left = self.trimBST(root.left, low, high)</span><br><span class="line">        root.right = self.trimBST(root.right, low, high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode108-将有序数组转换为二叉搜索树"><a href="#Leetcode108-将有序数组转换为二叉搜索树" class="headerlink" title="Leetcode108 将有序数组转换为二叉搜索树"></a>Leetcode108 将有序数组转换为二叉搜索树</h2><p>用二分的思想，就能达到平衡的效果</p>
<p>再用前序的思想递归的构建即可</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(val = nums[mid])</span><br><span class="line">        nums_left = nums[:mid]</span><br><span class="line">        nums_right = nums[mid+<span class="number">1</span>:]</span><br><span class="line">        root.left = self.sortedArrayToBST(nums_left)</span><br><span class="line">        root.right = self.sortedArrayToBST(nums_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode 刷题</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 二叉树修改与构造篇</title>
    <url>/2024/02/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<p>Leetcode刷题记录——二叉树修改与构造篇</p>
<span id="more"></span>
<h2 id="Leetcode226-翻转二叉树"><a href="#Leetcode226-翻转二叉树" class="headerlink" title="Leetcode226 翻转二叉树"></a>Leetcode226 翻转二叉树</h2><p>只要能遍历每个节点，然后改变左右子树的遍历方式都可以做到</p>
<p>本题采用的是层序遍历</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mirrorTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                node.left, node.right = node.right, node.left</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode106-从中序与后序遍历序列构造二叉树"><a href="#Leetcode106-从中序与后序遍历序列构造二叉树" class="headerlink" title="Leetcode106 从中序与后序遍历序列构造二叉树"></a>Leetcode106 从中序与后序遍历序列构造二叉树</h2><p>给定一个二叉树的中序遍历数组和后序遍历数组，来还原一颗二叉树，理论部分很简单</p>
<p>先后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组</p>
<p>一层一层切下去，每次后序数组最后一个元素就是当前子树根节点元素</p>
<p>说到一层一层切割，就应该想到了递归</p>
<p>来看一下一共分几步：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = postorder[-<span class="number">1</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        <span class="comment"># 找到前序中的切割下标</span></span><br><span class="line">        idx = inorder.index(root_val)</span><br><span class="line">        <span class="comment"># 得到前序中的左右子树数组</span></span><br><span class="line">        inorder_left = inorder[:idx]</span><br><span class="line">        inorder_right = inorder[idx+<span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># 得到后序中的左右子树数组</span></span><br><span class="line">        postorder_left = postorder[:<span class="built_in">len</span>(inorder_left)]</span><br><span class="line">        postorder_right = postorder[<span class="built_in">len</span>(inorder_left):<span class="built_in">len</span>(postorder)-<span class="number">1</span>]</span><br><span class="line">        root.left = self.buildTree(inorder_left, postorder_left)</span><br><span class="line">        root.right = self.buildTree(inorder_right, postorder_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode654-最大二叉树"><a href="#Leetcode654-最大二叉树" class="headerlink" title="Leetcode654 最大二叉树"></a>Leetcode654 最大二叉树</h2><p>构造一棵二叉树时，考虑用<strong>前序遍历</strong>的方式，先构造中间节点，再去递归地构造左子树和右子树</p>
<p><strong>还是递归三部曲：</strong></p>
<p>1、确定递归函数的参数和返回值</p>
<p>参数传入的是存放元素的数组，返回该数组构造的二叉树的根结点</p>
<p>2、确定终止条件</p>
<p>题目中说了输入的数组大小一定是大于等于1的，所以不用考虑小于1的情况</p>
<p>当递归遍历的时候，如果传入的数组大小为1，说明遍历到了叶子节点了</p>
<p>那么应该定义一个新的节点，并把这个数组的数值赋给新的节点</p>
<p>然后返回这个节点，这表示一个数组大小是1的时候，构造了一个新的节点，并返回</p>
<p>3、确定单层递归的逻辑</p>
<p>有三步：</p>
<p>1、先要找到数组中最大的值和对应的下标， 最大的值构造根节点，下标用来下一步分割数组</p>
<p>2、最大值所在的下标左区间 构造左子树</p>
<p>3、最大值所在的下标右区间 构造右子树</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">        max_val = <span class="built_in">max</span>(nums)</span><br><span class="line">        index = nums.index(max_val)</span><br><span class="line">        node = TreeNode(max_val)</span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            nums_left = nums[:index]</span><br><span class="line">            node.left = self.constructMaximumBinaryTree(nums_left)</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">            nums_right = nums[index+<span class="number">1</span>:]</span><br><span class="line">            node.right = self.constructMaximumBinaryTree(nums_right)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode617-合并二叉树"><a href="#Leetcode617-合并二叉树" class="headerlink" title="Leetcode617 合并二叉树"></a>Leetcode617 合并二叉树</h2><p><strong>还是递归三部曲：</strong></p>
<p>1、确定递归函数的参数和返回值</p>
<p>首先要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点</p>
<p>2、确定终止条件：</p>
<p>因为是传入了两个树，那么就有两个树遍历的节点<code>root1</code>和 <code>root2</code>，如果<code>root1== NULL</code> 了，两个树合并就应该是 <code>root2</code>了（如果<code>root2</code>也为<code>NULL</code>也无所谓，合并之后就是<code>NULL</code>）</p>
<p>反过来如果<code>root2== NULL</code>，那么两个数合并就是<code>root1</code>（如果<code>root1</code>也为<code>NULL</code>也无所谓，合并之后就是<code>NULL</code>）</p>
<p>3、确定单层递归的逻辑</p>
<p>单层递归的逻辑比较简单，就要把两棵树的元素加到一起</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1:</span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        val = root1.val + root2.val</span><br><span class="line">        node = TreeNode(val)</span><br><span class="line">        node.left = self.mergeTrees(root1.left, root2.left)</span><br><span class="line">        node.right = self.mergeTrees(root1.right, root2.right)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode 刷题</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树修改与构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 二叉树属性篇</title>
    <url>/2024/02/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E5%B1%9E%E6%80%A7%E7%AF%87/</url>
    <content><![CDATA[<p>Leetcode刷题记录——二叉树属性篇</p>
<span id="more"></span>
<h2 id="Leetcode101-对称二叉树"><a href="#Leetcode101-对称二叉树" class="headerlink" title="Leetcode101 对称二叉树"></a>Leetcode101 对称二叉树</h2><p><strong>递归三部曲</strong></p>
<p>1、确定递归函数的参数和返回值</p>
<p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p>
<p>返回值自然是<code>bool</code>类型。</p>
<p>2、确定终止条件</p>
<p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p>
<p>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p>
<ul>
<li>左节点为空，右节点不为空，不对称，<code>return false</code></li>
<li>左不为空，右为空，不对称 <code>return false</code></li>
<li>左右都为空，对称，<code>return true</code></li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同就<code>return false</code></li>
</ul>
<p>3、确定单层递归的逻辑</p>
<p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回<code>true</code> ，有一侧不对称就返回<code>false</code> 。</li>
</ul>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.compare(root.left, root.right)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> left.val != right.val: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        outside = self.compare(left.left, right.right)</span><br><span class="line">        inside = self.compare(left.right, right.left)</span><br><span class="line">        isSame = outside <span class="keyword">and</span> inside</span><br><span class="line">        <span class="keyword">return</span> isSame</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode110-平衡二叉树"><a href="#Leetcode110-平衡二叉树" class="headerlink" title="Leetcode110 平衡二叉树"></a>Leetcode110 平衡二叉树</h2><p>求高度(到叶子节点的距离) 用后序遍历</p>
<p>求深度(到根节点的距离) 用前序遍历</p>
<p><strong>递归三部曲：</strong></p>
<p>1、明确递归函数的参数和返回值</p>
<p>参数：当前传入节点    返回值：以当前传入节点为根的树的高度</p>
<p>如果，某个节点为根的二叉树已经不是平衡二叉树，那么返回高度就没有必要了，可以返回<code>-1</code></p>
<p>2、明确终止条件</p>
<p>递归的过程中依然是遇到空节点了为终止，返回<code>0</code>，表示当前节点为根节点的树高度为<code>0</code></p>
<p>3、明确单层递归的逻辑</p>
<p>分别求其左右子树的高度，然后如果差值小于等于<code>1</code>，则返回当前二叉树的高度，否则返回<code>-1</code>，表示已经不是二叉平衡树了。</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> self.get_height(root) == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_height</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.get_height(root.left)</span><br><span class="line">        right = self.get_height(root.right)</span><br><span class="line">        <span class="keyword">if</span> left == -<span class="number">1</span> <span class="keyword">or</span> right == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left, right)</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode257-二叉树的所有路径"><a href="#Leetcode257-二叉树的所有路径" class="headerlink" title="Leetcode257 二叉树的所有路径"></a>Leetcode257 二叉树的所有路径</h2><p><strong>依旧是递归三部曲：</strong></p>
<p>1、递归函数参数以及返回值</p>
<p>传入根节点，记录每一条路径的<code>path</code>，和存放最终结果的<code>res</code></p>
<p>2、确定递归的终止条件</p>
<p><strong>那么什么时候算是找到了叶子节点？</strong> 是当 <code>cur</code>不为空，其左右孩子都为空的时候，就找到叶子节点。</p>
<p>3、确定单层递归逻辑</p>
<p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进<code>path</code>中。</p>
<p><code>path.append(cur.val)</code></p>
<p>然后是递归和回溯的过程，上面说过没有判断<code>cur</code>是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。</p>
<p>此时还没完，递归完，要做回溯，因为<code>path</code> 不能一直加入节点，它还要删节点，然后才能加入新的节点</p>
<p>我们知道，<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯，所以回溯要和递归永远在一起</strong></p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        self.traversal(root, path, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, cur, path, result</span>):</span><br><span class="line">        path.append(cur.val)</span><br><span class="line">        <span class="comment"># 说明到达了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">            <span class="comment"># path数组里元素是int, 不能直接join, 要转换str</span></span><br><span class="line">            str_path = <span class="string">&#x27;-&gt;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,path))</span><br><span class="line">            result.append(str_path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> cur.left:</span><br><span class="line">            self.traversal(cur.left, path, result)</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">if</span> cur.right:</span><br><span class="line">            self.traversal(cur.right, path, result)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode404-左叶子之和"><a href="#Leetcode404-左叶子之和" class="headerlink" title="Leetcode404 左叶子之和"></a>Leetcode404 左叶子之和</h2><p><strong>依旧是递归三部曲：</strong></p>
<p>1、确定递归函数的参数和返回值</p>
<p>判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和</p>
<p>2、确定终止条件</p>
<p>如果遍历到空节点，那么<code>return 0</code></p>
<p>3、确定单层递归逻辑</p>
<p>当遇到左叶子节点的时候，记录数值；然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_num = self.sumOfLeftLeaves(root.left)</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.right:</span><br><span class="line">            left_num = root.left.val</span><br><span class="line">        right_num = self.sumOfLeftLeaves(root.right)</span><br><span class="line">        <span class="built_in">sum</span> = left_num + right_num</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode112-路径总和"><a href="#Leetcode112-路径总和" class="headerlink" title="Leetcode112 路径总和"></a>Leetcode112 路径总和</h2><p><strong>还是递归三部曲，一直总结加强记忆：</strong></p>
<p>1、确定递归函数的参数和返回值</p>
<p>参数：需要当前子树的根节点和一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和</p>
<p><strong>递归函数什么时候需要或者不需要返回值：</strong></p>
<ul>
<li>如果需要<strong>搜索</strong>整棵二叉树且不用处理递归返回值，递归函数就不要返回值</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。(本题的情况)</li>
</ul>
<p>2、确定终止条件</p>
<p>如果每次递归累加<code>val</code>，代码处理起来比较麻烦，可以考虑每次递归时，减去当前的<code>val</code></p>
<p>如果最后<code>targetSum == 0</code>，同时到了叶子节点的话，说明找到了目标和。</p>
<p>如果遍历到了叶子节点，<code>targetSum</code>不为<code>0</code>，就是没找到。</p>
<p>3、确定单层递归的逻辑</p>
<p>因为目前很多题都是遍历到叶子节点，<code>tarversal</code>一开始没有判断空指针</p>
<p>所以在进入递归前要判断其是否是空指针</p>
<p>递归函数是有返回值的，如果递归函数返回<code>true</code>，说明找到了合适的路径，应该立刻返回</p>
<p>而且这道题要注意递归完之后的回溯，减掉的<code>val</code>要再加回去</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.tarversal(root, targetSum-root.val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tarversal</span>(<span class="params">self, root, targetSum</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> targetSum == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> targetSum != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            targetSum -= root.left.val</span><br><span class="line">            <span class="keyword">if</span> self.tarversal(root.left, targetSum):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            targetSum += root.left.val</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            targetSum -= root.right.val</span><br><span class="line">            <span class="keyword">if</span> self.tarversal(root.right, targetSum):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            targetSum += root.right.val</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode 刷题</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树属性</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 二叉树遍历篇</title>
    <url>/2024/01/31/%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E9%81%8D%E5%8E%86%E7%AF%87/</url>
    <content><![CDATA[<p>Leetcode刷题记录——二叉树遍历篇</p>
<span id="more"></span>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<h2 id="Leetcode144-二叉树的前序遍历"><a href="#Leetcode144-二叉树的前序遍历" class="headerlink" title="Leetcode144 二叉树的前序遍历"></a>Leetcode144 二叉树的前序遍历</h2><p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 先定义一个要返回的result列表</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 将根节点、result传入preTraversal函数, 该函数负责递归调用</span></span><br><span class="line">        self.preTraversal(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], result</span>):</span><br><span class="line">        <span class="comment"># 终止条件的确定, 如果当前节点为空, 则返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 确定单层递归的逻辑，前序是根左右</span></span><br><span class="line">        result.append(root.val)</span><br><span class="line">        self.preTraversal(root.left, result)</span><br><span class="line">        self.preTraversal(root.right, result)</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode145-二叉树的后序遍历"><a href="#Leetcode145-二叉树的后序遍历" class="headerlink" title="Leetcode145 二叉树的后序遍历"></a>Leetcode145 二叉树的后序遍历</h2><p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        self.postTraversal(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.postTraversal(root.left, result)</span><br><span class="line">        self.postTraversal(root.right, result)</span><br><span class="line">        result.append(root.val)</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode94-二叉树的中序遍历"><a href="#Leetcode94-二叉树的中序遍历" class="headerlink" title="Leetcode94 二叉树的中序遍历"></a>Leetcode94 二叉树的中序遍历</h2><p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        self.inTraversal(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], result</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inTraversal(root.left, result)</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        self.inTraversal(root.right, result)</span><br></pre></td></tr></table></figure>

<h2 id="非递归方法-迭代法"><a href="#非递归方法-迭代法" class="headerlink" title="非递归方法(迭代法)"></a>非递归方法(迭代法)</h2><p>递归的实现其实也是栈，而迭代法是显示的用栈的操作去实现树的遍历</p>
<h2 id="Leetcode144-二叉树的前序遍历-1"><a href="#Leetcode144-二叉树的前序遍历-1" class="headerlink" title="Leetcode144 二叉树的前序遍历"></a>Leetcode144 二叉树的前序遍历</h2><p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="comment"># 因为后进先出 所以右孩子入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode145-二叉树的后序遍历-1"><a href="#Leetcode145-二叉树的后序遍历-1" class="headerlink" title="Leetcode145 二叉树的后序遍历"></a>Leetcode145 二叉树的后序遍历</h2><p><strong>Python代码如下：</strong></p>
<p>前序遍历：根左右</p>
<p>后序遍历：左右根</p>
<p>将前序变成—&gt;根右左，最后的<code>res</code>再反转一下就是左右根</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode94-二叉树的中序遍历-1"><a href="#Leetcode94-二叉树的中序遍历-1" class="headerlink" title="Leetcode94 二叉树的中序遍历"></a>Leetcode94 二叉树的中序遍历</h2><p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># cur指针用作遍历整棵树</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="comment"># 先迭代访问到树的最左节点</span></span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment"># 当到最左时, cur为空</span></span><br><span class="line">            <span class="comment"># 此时弹出栈顶元素, res.append(node.val)</span></span><br><span class="line">            <span class="comment"># 并将cur指针交给其右孩子继续迭代</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                cur = node.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode102-二叉树的层序遍历"><a href="#Leetcode102-二叉树的层序遍历" class="headerlink" title="Leetcode102 二叉树的层序遍历"></a>Leetcode102 二叉树的层序遍历</h2><p>层序遍历就要用到队列的思想，先进先出</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []</span><br><span class="line">            <span class="comment"># 主要是每一层需要求出当前队列的长度, 即每一层的节点数</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode107-二叉树的层序遍历Ⅱ"><a href="#Leetcode107-二叉树的层序遍历Ⅱ" class="headerlink" title="Leetcode107 二叉树的层序遍历Ⅱ"></a>Leetcode107 二叉树的层序遍历Ⅱ</h2><p>与102一样的思路，要从底下遍历，只要把最后的<code>res</code>反转一下就行</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode199-二叉树的右视图"><a href="#Leetcode199-二叉树的右视图" class="headerlink" title="Leetcode199 二叉树的右视图"></a>Leetcode199 二叉树的右视图</h2><p>一样的思路，最后<code>res.append(level[-1])</code></p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(level[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode637-二叉树的层平均值"><a href="#Leetcode637-二叉树的层平均值" class="headerlink" title="Leetcode637 二叉树的层平均值"></a>Leetcode637 二叉树的层平均值</h2><p>一样的思路，每层求和再求平均即可</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            length = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="built_in">sum</span> += node.val</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            mean = <span class="built_in">sum</span> / length</span><br><span class="line">            res.append(mean)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode429-N叉树的遍历"><a href="#Leetcode429-N叉树的遍历" class="headerlink" title="Leetcode429 N叉树的遍历"></a>Leetcode429 N叉树的遍历</h2><p>一样的思路，只是在每个节点处需要遍历该节点的所有<code>children</code></p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">for</span> child <span class="keyword">in</span> node.children:</span><br><span class="line">                    queue.append(child)</span><br><span class="line">            res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode515-在每个树行中找最大值"><a href="#Leetcode515-在每个树行中找最大值" class="headerlink" title="Leetcode515 在每个树行中找最大值"></a>Leetcode515 在每个树行中找最大值</h2><p>一样的思路，只不过要记录最大值</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            max_val = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.val &gt; max_val:</span><br><span class="line">                    max_val = node.val</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(max_val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode116-填充每个节点的下一个右侧节点指针"><a href="#Leetcode116-填充每个节点的下一个右侧节点指针" class="headerlink" title="Leetcode116 填充每个节点的下一个右侧节点指针"></a>Leetcode116 填充每个节点的下一个右侧节点指针</h2><p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 这里一开始pre = None设置的比较巧妙</span></span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="comment"># 以及这里的处理</span></span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    pre.<span class="built_in">next</span> = node</span><br><span class="line">                pre = node</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode117-填充每个节点的下一个右侧节点指针II"><a href="#Leetcode117-填充每个节点的下一个右侧节点指针II" class="headerlink" title="Leetcode117 填充每个节点的下一个右侧节点指针II"></a>Leetcode117 填充每个节点的下一个右侧节点指针II</h2><p>跟116没区别，代码都一样</p>
<h2 id="Leetcode104-二叉树的最大深度"><a href="#Leetcode104-二叉树的最大深度" class="headerlink" title="Leetcode104 二叉树的最大深度"></a>Leetcode104 二叉树的最大深度</h2><p>最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode111-二叉树的最小深度"><a href="#Leetcode111-二叉树的最小深度" class="headerlink" title="Leetcode111 二叉树的最小深度"></a>Leetcode111 二叉树的最小深度</h2><p>只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="keyword">return</span> depth</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode 刷题</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 字符串篇</title>
    <url>/2024/01/18/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/</url>
    <content><![CDATA[<p>Leetcode刷题记录——字符串篇</p>
<span id="more"></span>

<h2 id="Leetcode344-反转字符串"><a href="#Leetcode344-反转字符串" class="headerlink" title="Leetcode344 反转字符串"></a>Leetcode344 反转字符串</h2><p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># s[left], s[right] = s[right], s[left]</span></span><br><span class="line">            <span class="comment"># Python 的一项语法糖，它可以在不借助临时变量的情况下直接交换两个变量的值</span></span><br><span class="line">            temp = s[left]</span><br><span class="line">            s[left] = s[right]</span><br><span class="line">            s[right] = temp</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode541-反转字符串Ⅱ"><a href="#Leetcode541-反转字符串Ⅱ" class="headerlink" title="Leetcode541 反转字符串Ⅱ"></a>Leetcode541 反转字符串Ⅱ</h2><p>每隔<code>2k</code>个字符，反转前<code>k</code>个，后<code>k</code>个不动</p>
<p>当循环结束时，判断剩余字符数量的区间，做不同的反转操作</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; length <span class="keyword">and</span> i+<span class="number">2</span>*k &lt;= length:</span><br><span class="line">            temp = s[i:i+k][::-<span class="number">1</span>]</span><br><span class="line">            res.append(temp)</span><br><span class="line">            res.append(s[i+k:i+<span class="number">2</span>*k])</span><br><span class="line">            i = i + <span class="number">2</span>*k</span><br><span class="line">        <span class="keyword">if</span> length - i &lt; k:</span><br><span class="line">            temp = s[i:][::-<span class="number">1</span>]</span><br><span class="line">            res.append(temp)</span><br><span class="line">        <span class="keyword">if</span> length - i &lt; <span class="number">2</span>*k <span class="keyword">and</span> length - i &gt;= k:</span><br><span class="line">            temp = s[i:i+k][::-<span class="number">1</span>]</span><br><span class="line">            res.append(temp)</span><br><span class="line">            res.append(s[i+k:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode151-翻转字符串里的单词"><a href="#Leetcode151-翻转字符串里的单词" class="headerlink" title="Leetcode151 翻转字符串里的单词"></a>Leetcode151 翻转字符串里的单词</h2><p>首先用一个<code>split</code>函数分割字符串</p>
<p>再用双指针，同样的反转字符串的操作</p>
<p>最后用 <code>&#39; &#39;.join()</code>合并就可以了</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseWords(self, s: str) -&gt; str:</span><br><span class="line">        words = s.split()</span><br><span class="line">        left = 0</span><br><span class="line">        right = len(words) - 1</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            words[left], words[right] = words[right], words[left]</span><br><span class="line">            left += 1</span><br><span class="line">            right -= 1</span><br><span class="line">        return &#x27; &#x27;.join(words)</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode28-找出字符串中第一个匹配项的下标"><a href="#Leetcode28-找出字符串中第一个匹配项的下标" class="headerlink" title="Leetcode28 找出字符串中第一个匹配项的下标"></a>Leetcode28 找出字符串中第一个匹配项的下标</h2><p><code>KMP</code>思想</p>
<p>主要是求出根据子串求<code>next</code>数组</p>
<p>讲起来太抽象，可以看代码随想录</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(needle)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(needle)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> needle[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>[i] = j</span><br><span class="line">        </span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):</span><br><span class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h2 id="Leetcode459-重复的子字符串"><a href="#Leetcode459-重复的子字符串" class="headerlink" title="Leetcode459 重复的子字符串"></a>Leetcode459 重复的子字符串</h2><p>如果这个字符串包含重复的子串</p>
<p>假设是字符串<code>abcabc</code>，记为<code>s</code></p>
<p>那么<code>s</code>一定包含在<code>s+s</code>内</p>
<p>所以判断字符串<code>s</code>是否由重复子串组成，只要两个<code>s</code>拼接在一起，里面还出现一个<code>s</code>的话，就说明是由重复子串组成</p>
<p>我们在判断<code> s + s</code>拼接的字符串里是否出现一个<code>s</code>的的时候，<strong>要刨除 s + s 的首字符和尾字符</strong>，这样避免在<code>s+s</code>中搜索出原来的<code>s</code>，我们要搜索的是中间拼接出来的<code>s</code></p>
<p>还是回到了<code>KMP</code>算法</p>
<p>只不过这道题的模式串变成了<code>(s+s)[1:-1]</code><strong>（拼接再去掉首位字符）</strong></p>
<p>子串变成了<code>s</code></p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def repeatedSubstringPattern(self, s: str) -&gt; bool:</span><br><span class="line">        next = [0] * len(s)</span><br><span class="line">        j = 0</span><br><span class="line">        needle = (s+s)[1:-1]</span><br><span class="line">        for i in range(1, len(s)):</span><br><span class="line">            while j &gt; 0 and s[j] != s[i]:</span><br><span class="line">                j = next[j-1]</span><br><span class="line">            if s[j] == s[i]:</span><br><span class="line">                j += 1</span><br><span class="line">            next[i] = j</span><br><span class="line">        </span><br><span class="line">        j = 0</span><br><span class="line">        needle = (s+s)[1:-1]</span><br><span class="line">        for i in range(len(needle)):</span><br><span class="line">            while j &gt; 0 and needle[i] != s[j]:</span><br><span class="line">                j = next[j-1]</span><br><span class="line">            if needle[i] == s[j]:</span><br><span class="line">                j += 1</span><br><span class="line">            if j == len(s):</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode 刷题</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 哈希表篇</title>
    <url>/2024/01/14/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/</url>
    <content><![CDATA[<p>Leetcode刷题记录——哈希表篇</p>
<span id="more"></span>

<h2 id="Leetcode242-有效的字母异位词"><a href="#Leetcode242-有效的字母异位词" class="headerlink" title="Leetcode242 有效的字母异位词"></a>Leetcode242 有效的字母异位词</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 首先定义一个record数组, 初始化全为0</span></span><br><span class="line">        record = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="comment"># 遍历s字符串, 因为都是小写字母, 所以用相对位置即可</span></span><br><span class="line">        <span class="comment"># 对于s字符串, 出现的字母下标位置+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            record[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 对于t字符串, 出现的字母下标位置-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            record[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果, t是s的字母异位词, 那么record数组1的地方应该刚好被抵消, 全为0</span></span><br><span class="line">        <span class="comment"># 否则t不是s的字母异位词</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> record:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h2 id="Leetcode349-两个数组的交集"><a href="#Leetcode349-两个数组的交集" class="headerlink" title="Leetcode349 两个数组的交集"></a>Leetcode349 两个数组的交集</h2><p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        count1 = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line">        count2 = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)):</span><br><span class="line">            count1[nums1[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">            count2[nums2[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(count1)):</span><br><span class="line">            <span class="keyword">if</span> count1[i] * count2[i] &gt; <span class="number">0</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="Leetcode202-快乐数"><a href="#Leetcode202-快乐数" class="headerlink" title="Leetcode202 快乐数"></a>Leetcode202 快乐数</h2><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要</strong></p>
<p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p>
<p>所以这道题目使用哈希法，来判断这个<code>sum</code>是否重复出现，如果重复了就是<code>return False</code>， 否则一直找到<code>sum</code>为1为止。</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(n):</span><br><span class="line">                <span class="built_in">sum</span> += <span class="built_in">int</span>(i) ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            res.add(<span class="built_in">sum</span>)</span><br><span class="line">            n = <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h2 id="Leetcode1-两数之和"><a href="#Leetcode1-两数之和" class="headerlink" title="Leetcode1 两数之和"></a>Leetcode1 两数之和</h2><p>简单的方式是直接两层<code>for</code>循环遍历所有可能的情况，但复杂度是O(n^2)</p>
<p>用<code>map</code>，也就是字典来解题</p>
<p>首先遍历<code>nums</code>，判断<code>target - value</code>是否出现在字典，若字典里有，则返回相应的下标</p>
<p>若没有，则将<code>value-index</code>这对键值对加入字典</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - value <span class="keyword">in</span> <span class="built_in">map</span>:</span><br><span class="line">                res.append(index)</span><br><span class="line">                res.append(<span class="built_in">map</span>[target-value])</span><br><span class="line">            <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">map</span>:</span><br><span class="line">                <span class="built_in">map</span>[value] = index</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





<h2 id="Leetcode383-赎金信"><a href="#Leetcode383-赎金信" class="headerlink" title="Leetcode383 赎金信"></a>Leetcode383 赎金信</h2><p>题目中说：<code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次</p>
<p>那么就考虑哈希表的思路去做</p>
<p>首先遍历<code>magazine</code>  ，将其中的字符以及个数添加到<code>map</code>中</p>
<p>再遍历<code>ransomNote</code>，如果其中字符存在<code>map</code>中，且<code>map[i] &gt; 0</code>，则对应<code> -1</code>，否则返回<code>False</code></p>
<p>若循环顺利结束，说明条件成立，返回<code>True</code> </p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            <span class="built_in">map</span>[i] = <span class="built_in">map</span>.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ransomNote:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> <span class="built_in">map</span> <span class="keyword">and</span> <span class="built_in">map</span>[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">map</span>[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h2 id="Leetcode454-四数相加II"><a href="#Leetcode454-四数相加II" class="headerlink" title="Leetcode454 四数相加II"></a>Leetcode454 四数相加II</h2><p>首先定义一个<code>map</code>，<code>key</code>是<code>a+b</code>的值，<code>value</code>是其出现的次数</p>
<p>再遍历<code>c+d</code>，若相加<code>=0</code>，则<code>count</code>加上对应的<code>value</code></p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="built_in">map</span>[a+b] = <span class="built_in">map</span>.get(a+b, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> nums4:</span><br><span class="line">                <span class="keyword">if</span> -(c+d) <span class="keyword">in</span> <span class="built_in">map</span> <span class="keyword">and</span> <span class="built_in">map</span>[-(c+d)] &gt; <span class="number">0</span>:</span><br><span class="line">                    count += <span class="built_in">map</span>[-(c+d)]</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>



<h2 id="Leetcode15-三数之和"><a href="#Leetcode15-三数之和" class="headerlink" title="Leetcode15 三数之和"></a>Leetcode15 三数之和</h2><p>首先将数组排序，然后有一层<code>for</code>循环，<code>i</code>从下标0的地方开始</p>
<p>同时定一个下标<code>left</code> 定义在<code>i+1</code>的位置上，定义下标<code>right</code>在数组结尾的位置上。</p>
<p>依然还是在数组中找到 <code>abc </code>使得<code>a + b +c =0</code></p>
<p>我们这里相当于 <code>a = nums[i]</code>，<code>b = nums[left]</code>，<code>c = nums[right]</code></p>
<p>接下来如何移动<code>left</code>和<code>right</code>呢， 如果<code>nums[i] + nums[left] + nums[right] &gt; 0 </code>就说明 此时三数之和大了，因为数组是排序后了，所以<code>right</code>下标就应该向左移动，这样才能让三数之和小一些。</p>
<p>如果 <code>nums[i] + nums[left] + nums[right] &lt; 0</code> 说明此时三数之和小了，<code>left</code> 就向右移动，才能让三数之和大一些，直到<code>left</code>与<code>right</code>相遇为止。</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 因为是排序后的, 如果nums[i], 那就没必要继续了</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="comment"># 每次i往后一位时，需要判断与之前是否相同,因为会重复</span></span><br><span class="line">            <span class="comment"># 看参考样例[-1,0,1,2,-1,-4]</span></span><br><span class="line">            <span class="keyword">if</span> i&gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="built_in">sum</span> = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">sum</span> &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    <span class="comment"># 当前位置匹配成功过,跳过相同元素避免重复</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right-<span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="Leetcode18-四数之和"><a href="#Leetcode18-四数之和" class="headerlink" title="Leetcode18 四数之和"></a>Leetcode18 四数之和</h2><p>四数之和的双指针解法是两层<code>for</code>循环<code>nums[i] + nums[j]</code>为确定值，依然是循环内有<code>left</code>和<code>right</code>下标作为双指针，找出<code>nums[i] + nums[j] + nums[left] + nums[right] == target</code>的情况，三数之和的时间复杂度是<code>O(n^2)</code>，四数之和的时间复杂度是<code>O(n^3)</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left = j + <span class="number">1</span></span><br><span class="line">                right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    <span class="built_in">sum</span> = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> &gt; target:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="built_in">sum</span> &lt; target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right-<span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode 刷题</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 数组篇</title>
    <url>/2024/01/06/%E6%95%B0%E7%BB%84%E7%AF%87/</url>
    <content><![CDATA[<p>Leetcode刷题记录——数组篇</p>
<span id="more"></span>

<h2 id="Leetcode704-二分查找"><a href="#Leetcode704-二分查找" class="headerlink" title="Leetcode704  二分查找"></a>Leetcode704  二分查找</h2><p><strong>使用二分查找的前提条件：</strong></p>
<ul>
<li>数组有序</li>
<li>数组内无重复元素（因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的）</li>
</ul>
<p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>？</p>
<p>因此要遵循<strong>循环不变量原则</strong>，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作</p>
<p>区间的定义一般为两种，左闭右闭即<code>[left, right]</code>，或者左闭右开即<code>[left, right)</code>，本题采用左闭右闭的写法</p>
<p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p>
<ul>
<li><code>while (left &lt;= right)</code> 要使用 <code>&lt;=</code> ，因为<code>left == right</code>是有意义的，在<code>[left, right]</code>区间是合法的，所以使用 <code>&lt;=</code></li>
<li><code>if (nums[middle] &gt; target)</code> <code>right</code> 要赋值为 <code>middle - 1</code>，因为当前这个<code>nums[middle]</code>一定不是<code>target</code>，那么接下来要查找的左区间结束下标位置就是 <code>middle - 1</code></li>
</ul>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[middle]:</span><br><span class="line">                right = middle -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; nums[middle]:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode35-搜索插入位置"><a href="#Leetcode35-搜索插入位置" class="headerlink" title="Leetcode35 搜索插入位置"></a>Leetcode35 搜索插入位置</h2><p>看到有序数组就可以想到二分</p>
<p>与上题一样，考虑循环不变量，注意区间整体保持一致</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            middle = left + (right-left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[middle]:</span><br><span class="line">                right = middle</span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[middle]:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[middle]:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode34-在排序数组中查找元素的第一个位置和最后一个位置"><a href="#Leetcode34-在排序数组中查找元素的第一个位置和最后一个位置" class="headerlink" title="Leetcode34 在排序数组中查找元素的第一个位置和最后一个位置"></a>Leetcode34 在排序数组中查找元素的第一个位置和最后一个位置</h2><p>一开始思路想的太复杂了</p>
<p>依旧是二分的思路，可以先不管里面是有重复的值，我只需要确定能找到就行</p>
<p>找到之后退出循环，定义<code>start</code>，<code>end</code>一个往前，一个往后，找到区间位置</p>
<p>如果退出循环的时候，<code>left  &gt;=  right</code>。说明在之前的循环里，没有找到<code>middle</code>，就是说<code>nums</code>里没有<code>target</code>，直接返回<code>[-1,-1]</code></p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)</span><br><span class="line">        middle = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            middle = left + (right-left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[middle]:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target &lt; nums[middle]:</span><br><span class="line">                right = middle</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        start = middle</span><br><span class="line">        end = middle</span><br><span class="line">        <span class="keyword">while</span> start &gt; <span class="number">0</span> <span class="keyword">and</span> nums[start-<span class="number">1</span>] == target:</span><br><span class="line">            start -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; <span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="keyword">and</span> nums[end+<span class="number">1</span>] == target:</span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode69-x的平方根"><a href="#Leetcode69-x的平方根" class="headerlink" title="Leetcode69 x的平方根"></a>Leetcode69 x的平方根</h2><p>依然可以考虑二分查</p>
<p>要注意的是平方根开不尽的话要向下取整</p>
<p>给定的数的平方根一定在某两个整数之间</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = x</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = left + (right-left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> middle * middle &lt;= x:</span><br><span class="line">                ans = middle</span><br><span class="line">                <span class="comment"># 注意是更新left, 向后面去找 </span></span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 注意是更新right</span></span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode367-有效的完全平方数"><a href="#Leetcode367-有效的完全平方数" class="headerlink" title="Leetcode367 有效的完全平方数"></a>Leetcode367 有效的完全平方数</h2><p>还是一样的二分查找</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPerfectSquare</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = num</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = left + (right-left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> middle * middle &lt; num:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> middle * middle &gt; num:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode26-删除有序数组中的重复项"><a href="#Leetcode26-删除有序数组中的重复项" class="headerlink" title="Leetcode26 删除有序数组中的重复项"></a>Leetcode26 删除有序数组中的重复项</h2><p>数组是有序的，那么出现不同的元素一定是相邻的</p>
<p>定义两个快慢指针，<code>slow=0</code>、 <code>fast=1</code></p>
<p><code>fast</code>往后走，遇到与<code>slow</code>不相同的数值时，把值赋给<code>slow+1</code>，之后<code>slow+1</code></p>
<p>重复此过程，直到<code>fast</code>走到底</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        fast = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] == nums[slow]:</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[slow+<span class="number">1</span>] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode27-移除元素"><a href="#Leetcode27-移除元素" class="headerlink" title="Leetcode27  移除元素"></a>Leetcode27  移除元素</h2><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p>也就是快指针去寻找符合条件的元素，慢指针用来更新需要返回的数组，这样在一次遍历中，即可完成数组的更新</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        fast = <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> fast &lt; length:</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow = slow + <span class="number">1</span></span><br><span class="line">            fast = fast + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode844-比较含退格的字符串"><a href="#Leetcode844-比较含退格的字符串" class="headerlink" title="Leetcode844 比较含退格的字符串"></a>Leetcode844 比较含退格的字符串</h2><p>因为<code>&#39;#&#39;</code>的出现是要删除前面的字符，所以考虑从后往前遍历</p>
<p>具体地，定义 <code>skip</code> 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p>
<p>若该字符为退格符，则我们需要多删除一个普通字符，我们让 <code>skip</code> 加 1；</p>
<p>若该字符为普通字符：</p>
<p>若 <code>skip</code> 为 0，则说明当前字符不需要删去；</p>
<p>若 <code>skip</code> 不为 0，则说明当前字符需要删去，让 <code>skip</code> 减 1</p>
<p>这样，定义两个指针，分别指向两字符串的末尾</p>
<p>每次让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较</p>
<p>重复这一过程直到找到的<strong>两个字符不相等</strong>，或其中<strong>某个字符串遍历完</strong>为止</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backspaceCompare</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        skipS = <span class="number">0</span></span><br><span class="line">        skipT = <span class="number">0</span></span><br><span class="line">        i = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        j = <span class="built_in">len</span>(t) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i] != <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> skipS &gt; <span class="number">0</span>:</span><br><span class="line">                    skipS -= <span class="number">1</span></span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> s[i] != <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> skipS == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    skipS += <span class="number">1</span></span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> t[j] != <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> skipT &gt; <span class="number">0</span>:</span><br><span class="line">                    skipT -= <span class="number">1</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> t[j] != <span class="string">&#x27;#&#x27;</span> <span class="keyword">and</span> skipT == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> t[j] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    skipT += <span class="number">1</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i] != t[j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> i &lt; <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode283-移动零"><a href="#Leetcode283-移动零" class="headerlink" title="Leetcode283 移动零"></a>Leetcode283 移动零</h2><p>依旧是双指针的思路</p>
<p>定义两个快慢指针，<code>slow=0</code>、 <code>fast=0</code></p>
<p>判断当前fast指针所在位置元素是否等于0</p>
<p>若不等于0，则与<code>slow</code>指针指向的元素交换位置，也就是把非零元素移到前面；若等于0，fast继续往后走</p>
<p>之后<code>slow+1</code>、 <code>fast+1</code>，直到<code>fast</code>走到底</p>
<p>最后非零元素则是全部移动到了最后</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span>  nums</span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        fast = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != <span class="number">0</span>:</span><br><span class="line">                nums[slow], nums[fast] = nums[fast], nums[slow]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode977-有序数组的平方"><a href="#Leetcode977-有序数组的平方" class="headerlink" title="Leetcode977 有序数组的平方"></a>Leetcode977 有序数组的平方</h2><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>
<p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>此时可以考虑双指针法了，<code>head</code>指向起始位置，<code>tail</code>指向终止位置。</p>
<p>定义一个新数组<code>res</code>，和<code>nums</code>数组一样的大小，让<code>index</code>指向<code>res</code>数组终止位置。</p>
<p><strong>Pytho代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        head = <span class="number">0</span></span><br><span class="line">        tail = length - <span class="number">1</span></span><br><span class="line">        index = length - <span class="number">1</span></span><br><span class="line">        res = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> head &lt;= tail:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(nums[head]) &gt; <span class="built_in">abs</span>(nums[tail]):</span><br><span class="line">                res[index] = nums[head] * nums[head]</span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[index] = nums[tail] * nums[tail]</span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode209-长度最小的子数组"><a href="#Leetcode209-长度最小的子数组" class="headerlink" title="Leetcode209 长度最小的子数组"></a>Leetcode209 长度最小的子数组</h2><p>首先想到的暴力法，思路很简单，两个<code>for</code>循环，找到所有的连续子组合，如果该组合<code>&gt;=target</code>则记录长度，最终返回长度最小的记录即可</p>
<p>这道题可以用<strong>滑动窗口</strong>的思想来解决：</p>
<p>在暴力解法中，是一个<code>for</code>循环为滑动窗口的起始位置，一个<code>for</code>循环为滑动窗口的终止位置，用两个<code>for</code>循环 完成了一个不断搜索区间的过程</p>
<p>那么滑动窗口如何用一个<code>for</code>循环来完成这个操作呢？</p>
<p>首先要思考，如果用一个<code>for</code>循环，那么应该表示滑动窗口的起始位置，还是终止位置？</p>
<p>如果只用一个<code>for</code>循环来表示滑动窗口的起始位置，那么如何遍历剩下的终止位置？</p>
<p>此时难免再次陷入暴力解法的怪圈</p>
<p>所以 如果只用一个<code>for</code>循环，那么这个循环的索引，一定是表示滑动窗口的终止位置</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        max_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="built_in">sum</span> = <span class="built_in">sum</span> + nums[end]</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">sum</span> &gt;= target:</span><br><span class="line">                <span class="comment"># 如果此时窗口内的和&gt;=target,那么试着剔除窗口的第一个元素，看是否还成立</span></span><br><span class="line">                <span class="comment"># 但操作前,需要先记录此时成立情况下的窗口长度</span></span><br><span class="line">                res = end - start + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> res &lt; max_len:</span><br><span class="line">                    max_len = res</span><br><span class="line">                <span class="built_in">sum</span> = <span class="built_in">sum</span> - nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> max_len == inf:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode904-水果成篮"><a href="#Leetcode904-水果成篮" class="headerlink" title="Leetcode904 水果成篮"></a>Leetcode904 水果成篮</h2><p>题目翻译成人话：找至多包含两种元素的最长子串，并返回其长度</p>
<p>这道题的思路和滑动窗口类似</p>
<p>一个<code>for</code>循环去遍历<code>end</code>的位置，遍历所有种类小于2的情况，中间记录最大的长度，最后返回</p>
<p>用一个<code>map</code>记录出现的元素以及次数</p>
<p>每次将<code>end</code>移动一个位置，并将当前元素加入哈希表</p>
<p>如果此时哈希表不满足要求（即哈希表中出现超过两个键值对），那么我们需要不断移动<code>start</code>，并将 <code>fruits[start]</code>从哈希表中对应的值<code>-1</code>，需要注意的是，将 <code>fruits[start]</code>从哈希表中<code>-1</code>后，如果 <code>fruits[start]</code>在哈希表中的出现次数减少为<code> 0</code>，需要将对应的键值对从哈希表中移除</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">totalFruit</span>(<span class="params">self, fruits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(fruits):</span><br><span class="line">            <span class="built_in">map</span>[item] = <span class="built_in">map</span>.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(<span class="built_in">map</span>) &gt; <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">map</span>[fruits[start]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">map</span>[fruits[start]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> <span class="built_in">map</span>[fruits[start]]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, end-start+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode76-最小覆盖子串"><a href="#Leetcode76-最小覆盖子串" class="headerlink" title="Leetcode76 最小覆盖子串"></a>Leetcode76 最小覆盖子串</h2><p>依然是滑动窗口方法</p>
<p>首先用一个<code>map</code>存储<code>t</code>中所有的元素以及出现的次数</p>
<p>定义<code>start</code>、<code>end</code>指针</p>
<p>定义一个<code>for</code>循环，先让<code>end</code>指针在<code>s</code>中往后走，走到第一个符合条件的位置(遇到<code>map</code>里的元素，对应位置<code>-1</code>，表示用过该元素一次了)</p>
<p>符合条件的语句为<code>all(value &lt;= 0 for value in map.values())</code>，表示<code>map</code>中所有位置的元素均小于等于<code>0</code>，因为<code>s</code>中的子串只要包含<code>t</code>即可，不一定所有元素一一对应的包含，比方说s里面’…aa…’，但是t中只有’.a…’也算是包含</p>
<p>接着让<code>start</code>指针往后走，看看有没有更优解</p>
<p>如果<code>s[start]</code>未在<code>map</code>中，那么<code>start</code>可以直接<code>+1</code></p>
<p>如果<code>s[start]</code>出现在<code>map</code>中，那么<code>map</code>中的对应位置要<code>+1</code>，<code>start+1</code></p>
<p><code>start</code>在走的时候要套在<code>while</code>循环里，也就是说当<code>while</code>循环不成立时，<code>start</code>走到了第一次不成立的位置，此后<code>end</code>再继续往后走</p>
<p>遍历的时候一直在记录成立的子串，最后返回最短的那个即可</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            <span class="built_in">map</span>[i] = <span class="built_in">map</span>.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> end, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> <span class="built_in">map</span>:</span><br><span class="line">                <span class="built_in">map</span>[item] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">all</span>(value &lt;= <span class="number">0</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">map</span>.values()):</span><br><span class="line">                <span class="keyword">if</span> end-start+<span class="number">1</span> &lt; min_len:</span><br><span class="line">                    min_len = end-start+<span class="number">1</span></span><br><span class="line">                    res = s[start:end+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> s[start] <span class="keyword">in</span> <span class="built_in">map</span>:</span><br><span class="line">                    <span class="built_in">map</span>[s[start]] += <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode54-螺旋矩阵"><a href="#Leetcode54-螺旋矩阵" class="headerlink" title="Leetcode54 螺旋矩阵"></a>Leetcode54 螺旋矩阵</h2><p>在二维数组中，记住这个求行列大小的方法</p>
<p><code>rows = len(matrix)</code><br><code>cols = len(matrix[0])</code></p>
<p>用一个<code>visted</code>记录<code>matrix</code>某个位置是否被访问过</p>
<p>定义<code>directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]</code>表示方向</p>
<p>例如，往右走是<code>row+0</code>，<code>col+1</code>，定义在<code>directions[0]</code>中</p>
<p>接下来就是按照顺序在<code>matrix</code>中走，判断<code>row</code>，<code>col</code>是否越界的同时判断<code>visted</code>是否被访问过来改变走的方向</p>
<p>每一次循环都会填入一个值，循环结束返回即可</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        nums = [<span class="number">0</span>] * (rows * cols)</span><br><span class="line">        visted = [[<span class="number">0</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        directions = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        row, col = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        directionIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = matrix[row][col]</span><br><span class="line">            visted[row][col] = <span class="number">1</span></span><br><span class="line">            nextRow = row + directions[directionIndex][<span class="number">0</span>]</span><br><span class="line">            newtCol = col + directions[directionIndex][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> nextRow &lt; <span class="number">0</span> <span class="keyword">or</span> nextRow &gt;= rows <span class="keyword">or</span> newtCol &lt; <span class="number">0</span> <span class="keyword">or</span> newtCol &gt;= cols <span class="keyword">or</span> visted[nextRow][newtCol] == <span class="number">1</span>:</span><br><span class="line">                directionIndex = (directionIndex+<span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>]</span><br><span class="line">            col += directions[directionIndex][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode59-螺旋矩阵II"><a href="#Leetcode59-螺旋矩阵II" class="headerlink" title="Leetcode59 螺旋矩阵II"></a>Leetcode59 螺旋矩阵II</h2><p>这道题考察对代码的掌控能力，仍然会遇到复杂的边界问题，坚持<strong>循环不变量原则</strong></p>
<p>模拟顺时针画矩阵的过程:</p>
<ul>
<li>填充上行从左到右</li>
<li>填充右列从上到下</li>
<li>填充下行从右到左</li>
<li>填充左列从下到上</li>
</ul>
<p>要处理好边界问题，就要坚持<strong>循环不变量原则</strong></p>
<p>本题采用<strong>左闭右开</strong>的写法</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 先创建 n * n 的全0矩阵</span></span><br><span class="line">        nums = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 偶数n能走完整圈,奇数n会留中间一个空</span></span><br><span class="line">        loop = n // <span class="number">2</span></span><br><span class="line">        <span class="comment"># n为奇数时, 矩阵的中间位置为nums[mid][mid]</span></span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        offset = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> loop:</span><br><span class="line">            <span class="comment"># 从左到右</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x, n - offset):</span><br><span class="line">                nums[x][i] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 从上到下</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(y, n - offset):</span><br><span class="line">                nums[i][n - offset] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 从右到左</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - offset, x, -<span class="number">1</span>):</span><br><span class="line">                nums[n - offset][i] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 从下到上</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - offset, y, -<span class="number">1</span>):</span><br><span class="line">                nums[i][y] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">            y += <span class="number">1</span></span><br><span class="line">            offset += <span class="number">1</span></span><br><span class="line">            loop -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            nums[mid][mid] = count</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode 刷题</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 栈和队列篇</title>
    <url>/2024/01/24/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%AF%87/</url>
    <content><![CDATA[<p>Leetcode刷题记录——栈和队列篇</p>
<span id="more"></span>

<h2 id="Leetcode232-用栈实现队列"><a href="#Leetcode232-用栈实现队列" class="headerlink" title="Leetcode232 用栈实现队列"></a>Leetcode232 用栈实现队列</h2><p>用一个栈肯定模拟不了队列的操作</p>
<p>要用两个栈</p>
<p>一个负责<code>push</code>，另一个负责<code>pop</code></p>
<ul>
<li><p>在<code>push</code>数据的时候，只要数据放进输入栈就好</p>
</li>
<li><p>但在<code>pop</code>的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）,再从输出栈弹出数据，如果输出栈不为空，则直接从输出栈弹出数据就可以了</p>
</li>
<li><p>如果进栈和出栈都为空的话，说明模拟的队列为空了</p>
</li>
</ul>
<p>注意：代码能复用的地方复用，不要再另外写逻辑</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.stack_out:</span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.stack_in)):</span><br><span class="line">                self.stack_out.append(self.stack_in.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = self.pop()</span><br><span class="line">        self.stack_out.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span>(self.stack_in <span class="keyword">or</span> self.stack_out)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode225-用队列实现栈"><a href="#Leetcode225-用队列实现栈" class="headerlink" title="Leetcode225 用队列实现栈"></a>Leetcode225 用队列实现栈</h2><p>用两个队列<code>que1</code>和<code>que2</code>实现队列的功能，<code>que2</code>其实完全就是一个备份的作用</p>
<p>把<code>que1</code>最后面的元素以外的元素都备份到<code>que2</code>，然后弹出最后面的元素(相当于弹出栈顶元素)，再把其他元素从<code>que2</code>导回<code>que1</code></p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue_in = deque()</span><br><span class="line">        self.queue_out = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.queue_in) - <span class="number">1</span>):</span><br><span class="line">            self.queue_out.append(self.queue_in.popleft())</span><br><span class="line">        </span><br><span class="line">        self.queue_in, self.queue_out = self.queue_out, self.queue_in</span><br><span class="line">        <span class="keyword">return</span> self.queue_out.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.queue_in[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue_in) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode20-有效的括号"><a href="#Leetcode20-有效的括号" class="headerlink" title="Leetcode20 有效的括号"></a>Leetcode20 有效的括号</h2><p>遇到左字符<code>&#123;</code>、<code>[</code>、<code>(</code>时压入栈</p>
<p>碰到右字符时，先检查栈是否为空，为空直接<code>False</code></p>
<p>在检查是否与栈顶元素成对匹配，不匹配直接<code>False</code>，是的话栈顶元素出栈</p>
<p>最后检查栈是否为空，为空说明全部能成对，返回<code>True</code></p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> i == <span class="string">&#x27;[&#x27;</span> <span class="keyword">or</span> i == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> stack[-<span class="number">1</span>] != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> stack[-<span class="number">1</span>] != <span class="string">&#x27;[&#x27;</span> :</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> stack[-<span class="number">1</span>] != <span class="string">&#x27;&#123;&#x27;</span> :</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode1047-删除字符串中的所有相邻重复项"><a href="#Leetcode1047-删除字符串中的所有相邻重复项" class="headerlink" title="Leetcode1047 删除字符串中的所有相邻重复项"></a>Leetcode1047 删除字符串中的所有相邻重复项</h2><p>遍历<code>s</code> ，如果栈非空并且栈顶元素等于当前正在遍历元素的话</p>
<p>栈顶元素出栈，否则，当前正在遍历元素压入栈</p>
<p>遍历到最后只剩下不重复的字符</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] == i:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h2 id="Leetcode150-逆波兰式表达求值"><a href="#Leetcode150-逆波兰式表达求值" class="headerlink" title="Leetcode150 逆波兰式表达求值"></a>Leetcode150 逆波兰式表达求值</h2><p>遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add, sub, mul</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        op = &#123;<span class="string">&#x27;+&#x27;</span>: add, <span class="string">&#x27;-&#x27;</span>:sub , <span class="string">&#x27;*&#x27;</span>:mul, <span class="string">&#x27;/&#x27;</span>:<span class="keyword">lambda</span> x, y : <span class="built_in">int</span>(x/y)&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>&#125;:</span><br><span class="line">                <span class="comment"># 也可以在这写stack.append(int(token)) 后面就不用那么多int()了</span></span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num2 = <span class="built_in">int</span>(stack.pop())</span><br><span class="line">                num1 = <span class="built_in">int</span>(stack.pop())</span><br><span class="line">                <span class="comment"># 第一个出来的在运算符后面</span></span><br><span class="line">                temp_num = op[i](num1, num2)</span><br><span class="line">                stack.append(temp_num)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(stack.pop())</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode239-滑动窗口最大值"><a href="#Leetcode239-滑动窗口最大值" class="headerlink" title="Leetcode239 滑动窗口最大值"></a>Leetcode239 滑动窗口最大值</h2><p><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</strong></p>
<p>那么这个维护元素单调递减的队列就叫做<strong>单调队列，即单调递减或单调递增的队列。</strong></p>
<p>设计单调队列的时候，<code>pop</code>，和<code>push</code>操作要保持如下规则：</p>
<ol>
<li><code>pop(self, value)</code>：如果窗口移除的元素<code>value</code>等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作。因为<code>push</code>的时候会将元素小的弹出了。</li>
<li><code>push(self, value)</code>：如果<code>push</code>的元素<code>value</code>大于入口元素的数值，那么就将队列入口的元素弹出，直到<code>push</code>元素的数值小于等于队列入口元素的数值为止</li>
</ol>
<p>保持如上规则，每次窗口移动的时候，只要问<code>que.front()</code>就可以返回当前窗口的最大值。</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue = deque()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> self.queue <span class="keyword">and</span> value == self.queue[<span class="number">0</span>]:</span><br><span class="line">            self.queue.popleft()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="comment"># 不是value &gt;= self.queue[-1] value等于队列末尾的时候不能弹出，依然要维护，因为窗口会移动的</span></span><br><span class="line">        <span class="keyword">while</span> self.queue <span class="keyword">and</span> value &gt; self.queue[-<span class="number">1</span>]:</span><br><span class="line">            self.queue.pop()</span><br><span class="line">        self.queue.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        que = MyQueue()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">        res.append(que.front())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 弹出的是窗口左端前面的那个, 所以是i-k, 错的时候写成了i-k+1</span></span><br><span class="line">            que.pop(nums[i-k])</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">            res.append(que.front())</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="Leetcode347-前K个高频元素"><a href="#Leetcode347-前K个高频元素" class="headerlink" title="Leetcode347 前K个高频元素"></a>Leetcode347 前K个高频元素</h2><p>总共涉及3个步骤：</p>
<p>1、遍历<code>nums</code>，用一个<code>map</code>存储键为元素，值为对应元素出现的次数</p>
<p>2、对次数进行排序</p>
<p>3、返回<code>top_k</code></p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">map</span>[nums[i]] = <span class="built_in">map</span>.get(nums[i], <span class="number">0</span> ) + <span class="number">1</span></span><br><span class="line">        sort_map = <span class="built_in">sorted</span>(<span class="built_in">map</span>.items(), key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        top_k = [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> sort_map[<span class="number">0</span>:k]]</span><br><span class="line">        <span class="keyword">return</span> top_k</span><br></pre></td></tr></table></figure>

<p>学完树再来用堆的思想来做</p>
]]></content>
      <categories>
        <category>Leetcode 刷题</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 链表篇</title>
    <url>/2024/01/10/%E9%93%BE%E8%A1%A8%E7%AF%87/</url>
    <content><![CDATA[<p>Leetcode刷题记录——链表篇</p>
<span id="more"></span>

<h2 id="Leetcode203-移除链表"><a href="#Leetcode203-移除链表" class="headerlink" title="Leetcode203 移除链表"></a>Leetcode203 移除链表</h2><p>如果对于一个链表，头节点的操作和其他节点的操作需要2个逻辑的话，建立一个虚拟头节点往往会大大降低难度</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        current = dummy_head</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> current.<span class="built_in">next</span>.val == val:</span><br><span class="line">                current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode707-设计链表"><a href="#Leetcode707-设计链表" class="headerlink" title="Leetcode707 设计链表"></a>Leetcode707 设计链表</h2><p>特定位置插入删除的操作，要考虑好头尾结点的特殊情况就行</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.dummy_node = ListNode()</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        current = self.dummy_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> current.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        new_node = ListNode(val, <span class="literal">None</span>)</span><br><span class="line">        new_node.<span class="built_in">next</span> = self.dummy_node.<span class="built_in">next</span></span><br><span class="line">        self.dummy_node.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        new_node = ListNode(val, <span class="literal">None</span>)</span><br><span class="line">        current = self.dummy_node</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        new_node = ListNode(val, <span class="literal">None</span>)</span><br><span class="line">        current = self.dummy_node</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        new_node.<span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        current = self.dummy_node</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcoe206-反转链表"><a href="#Leetcoe206-反转链表" class="headerlink" title="Leetcoe206 反转链表"></a>Leetcoe206 反转链表</h2><p>首先定义一个<code>current</code>指针，指向头结点，<code>pre</code>指向<code>None</code></p>
<p>从头开始反转时，需要先定义一个<code>temp</code>指针保留<code>current.next</code></p>
<p>接着将<code>current.next</code>指向<code>pre</code>，再移动<code>pre</code>到<code>current</code>的位置，<code>current</code>再移到<code>temp</code>的位置</p>
<p>这是一次反转的操作</p>
<p>只要当前<code>current</code>非空，就可以一直进行</p>
<p>最后返回的<code>pre</code>就是头节点</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            temp = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = current</span><br><span class="line">            current = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode24-两两交换链表中的节点"><a href="#Leetcode24-两两交换链表中的节点" class="headerlink" title="Leetcode24 两两交换链表中的节点"></a>Leetcode24 两两交换链表中的节点</h2><p>卡了好久没找出错误，思维只定在了第一轮，还得是<code>gpt</code></p>
<p>问题在于你每次交换节点时，都将 <code>dummy_node.next</code> 指向了当前的 <code>temp</code> 节点，这样会导致 <code>dummy_node.next</code> 不断指向链表中的同一个节点，而不是每次都更新。在进行两两交换时，<code>dummy_node.next</code> 应该指向新的头节点，而不是固定地指向 <code>temp</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy_node = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            <span class="comment"># next_node = cur.next</span></span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            next_head = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            dummy_node.<span class="built_in">next</span> = temp</span><br><span class="line">            temp.<span class="built_in">next</span> = cur</span><br><span class="line">            cur.<span class="built_in">next</span> = next_head</span><br><span class="line">            cur= next_head</span><br><span class="line">        <span class="keyword">return</span> dummy_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>画图模拟过程就行</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy_node = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        cur = dummy_node</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            next_head = cur.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            temp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = temp.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>.<span class="built_in">next</span> = temp</span><br><span class="line">            temp.<span class="built_in">next</span> = next_head</span><br><span class="line">            cur = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>另有递归的写法，留到下次再回来做的时候想</p>
<h2 id="Leetcode19-删除链表的倒数第n个节点"><a href="#Leetcode19-删除链表的倒数第n个节点" class="headerlink" title="Leetcode19 删除链表的倒数第n个节点"></a>Leetcode19 删除链表的倒数第n个节点</h2><p>双指针的经典应用</p>
<p>如果要删除倒数第<code>n</code>个节点，让<code>fast</code>移动<code>n</code>步，然后让<code>fast</code>和<code>slow</code>同时移动，直到<code>fast</code>指向链表末尾。</p>
<p>删掉<code>slow.next</code>所指向的节点就可以了。</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_node = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        <span class="comment"># 创建两个指针，慢指针和快指针，并将它们初始化为虚拟节点</span></span><br><span class="line">        fast = dummy_node</span><br><span class="line">        slow = dummy_node</span><br><span class="line">        <span class="comment"># 快指针比慢指针快 n 步</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 当快指针走到链表尾节点时,slow刚好在要删除的那个节点的前一个节点,slow.next = slow.next.next就可以达到删除的目的了</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode160-链表相交"><a href="#Leetcode160-链表相交" class="headerlink" title="Leetcode160 链表相交"></a>Leetcode160 链表相交</h2><p>两链表若相交，则相交之后的长度是相同的，相交前的长度不同</p>
<p>首先遍历两链表，分别求出它们的长度<code>lenA</code>，<code> lenB</code></p>
<p>再求出它们的长度差<code>dif</code>，先让长的那个链表移动<code>dif</code>步，则两链表就在同一起跑线了</p>
<p>接着遍历到尾节点的同时判断<code>curA == curB</code></p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        lenA = <span class="number">0</span> </span><br><span class="line">        lenB = <span class="number">0</span></span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        <span class="keyword">while</span> curA:</span><br><span class="line">            curA = curA.<span class="built_in">next</span></span><br><span class="line">            lenA += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> curB:</span><br><span class="line">            curB = curB.<span class="built_in">next</span></span><br><span class="line">            lenB += <span class="number">1</span></span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        <span class="keyword">if</span> lenA &gt; lenB:</span><br><span class="line">            dif = lenA -lenB</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dif):</span><br><span class="line">                curA = curA.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dif = lenB - lenA</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dif):</span><br><span class="line">                curB = curB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> curA:</span><br><span class="line">            <span class="keyword">if</span> curA == curB:</span><br><span class="line">                <span class="keyword">return</span> curA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curA = curA.<span class="built_in">next</span></span><br><span class="line">                curB = curB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode142-环形链表Ⅱ"><a href="#Leetcode142-环形链表Ⅱ" class="headerlink" title="Leetcode142 环形链表Ⅱ"></a>Leetcode142 环形链表Ⅱ</h2><ul>
<li>首先判断链表中是否有环</li>
</ul>
<p>定义<code>slow</code>、<code>fast</code>指针，首先指向<code>head</code></p>
<p><code>slow</code>一次移动一步，<code>fast</code>一次移动两步</p>
<p><strong>若链表有环</strong>，<code>fast</code>一定比<code>slow</code>先进环</p>
<p>等到<code>slow</code>和<code>fast</code>都进环后，由于<code>fast</code>比<code>slow</code>每次多移动一步，并且在环内，这就变成了一个追及问题</p>
<p>也就是说，不论这个环多大，<code>fast</code>总能追上<code>slow</code></p>
<ul>
<li>然后需要找到环的入口</li>
</ul>
<p>假设从头结点到环形入口节点 的节点数为<code>x</code>。 环形入口节点到 <code>fast</code>指针与<code>slow</code>指针相遇节点 节点数为<code>y</code>。 从相遇节点再到环形入口节点节点数为 <code>z</code></p>
<p>相遇时：<code> slow</code>指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，<code>n</code>为<code>fast</code>指针在环内走了<code>n</code>圈才遇到<code>slow</code>指针， <code>（y+z）</code>为 一圈内节点的个数<code>A</code></p>
<p>因为<code>fast</code>指针是一步走两个节点，<code>slow</code>指针一步走一个节点， 所以 <code>fast</code>指针走过的节点数 &#x3D; <code>slow</code>指针走过的节点数 * 2：</p>
<p><code>(x + y) * 2 = x + y + n (y + z)</code></p>
<p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p>
<p>因为要找环形的入口，那么要求的是<code>x</code>，因为<code>x</code>表示头结点到 环形入口节点的的距离</p>
<p>所以要求<code>x</code> ，将<code>x</code>单独放在左面：<code>x = n (y + z) - y</code> </p>
<p>再从<code>n(y+z)</code>中提出一个<code>（y+z）</code>来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里<code>n</code>一定是大于等于1的，因为 <code>fast</code>指针至少要多走一圈才能相遇<code>slow</code>指针</p>
<p>这个公式说明什么呢？</p>
<p>先拿<code>n为1</code>的情况来举例，意味着<code>fast</code>指针在环形里转了一圈之后，就遇到了<code>slow</code>指针了。</p>
<p>当 <code>n为1</code>的时候，公式就化解为 <code>x = z</code>，</p>
<p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p>
<p>也就是在相遇节点处，定义一个指针<code>index1</code>，在头结点处定一个指针<code>index2</code></p>
<p>让<code>index1</code>和<code>index2</code>同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点</p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="comment"># 为什么不写 while fast.next and fast.next.next</span></span><br><span class="line">        <span class="comment"># 会出现头结点为[]时, 会报错Nonetype has attribute next, null没有next了</span></span><br><span class="line">        <span class="comment"># ps:而且判断条件是按顺序来的, 写在前面的先判断, 如果前面错了就不往后判断了</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                slow = head</span><br><span class="line">                <span class="keyword">while</span> slow != fast:</span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> slow</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode82-删除链表中的重复元素Ⅱ"><a href="#Leetcode82-删除链表中的重复元素Ⅱ" class="headerlink" title="Leetcode82 删除链表中的重复元素Ⅱ"></a>Leetcode82 删除链表中的重复元素Ⅱ</h2><p>当<code>cur</code>指向的节点值与<code>cur.next</code>指向的节点值相同时</p>
<p>就让<code>cur</code>不断向后移动，直到<code>cur</code>指向的节点值与<code>cur.next</code>指向的节点值不相同时，停止移动</p>
<p>此时，判断<code>pre.next</code>是否等于<code>cur</code>，如果相等，说明<code>pre</code>与<code>cur</code>之间没有重复节点，就让<code>pre</code>移动到<code>cur</code>的位置否则，说明<code>pre</code>与<code>cur</code> 之间有重复节点，我们就让<code>pre.next</code>指向<code>cur.next</code></p>
<p>然后让<code>cur</code>继续向后移动</p>
<p>继续上述操作，直到 <code>cur</code>为空，遍历结束</p>
<p>最后返回<code>dummy_node.next</code></p>
<p><strong>Python代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_node = pre = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.val == cur.val:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> pre.<span class="built_in">next</span> == cur:</span><br><span class="line">                pre = cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode 刷题</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
